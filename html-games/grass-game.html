<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Lawn Arena</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #2c1e16;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .hud-row {
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }
        .score-box {
            background: rgba(0, 0, 0, 0.7);
            border: 4px solid;
            padding: 10px 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            border-radius: 8px;
            text-shadow: 2px 2px 0 #000;
            transition: transform 0.1s;
        }
        #timer-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 4px solid #fff;
            padding: 10px 30px;
            color: white;
            font-size: 32px;
            font-weight: bold;
            border-radius: 8px;
            text-shadow: 2px 2px 0 #000;
        }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
            z-index: 10;
        }
        h1 { font-size: 64px; text-shadow: 4px 4px 0 #e53935; margin-bottom: 10px; text-align: center; }
        p { font-size: 20px; margin-bottom: 30px; text-align: center; max-width: 650px; line-height: 1.5; }
        button {
            background: #e53935;
            border: 4px solid #b71c1c;
            color: white;
            font-size: 32px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            padding: 15px 40px;
            cursor: pointer;
            box-shadow: 0 8px 0 #b71c1c;
            transition: transform 0.1s, box-shadow 0.1s;
            border-radius: 8px;
        }
        button:active {
            transform: translateY(8px);
            box-shadow: 0 0px 0 #b71c1c;
        }
        
        #score-p1 { border-color: #e53935; color: #ffcdd2; }
        #score-p2 { border-color: #43a047; color: #c8e6c9; }
        #score-p3 { border-color: #fdd835; color: #fff9c4; }
        #score-p4 { border-color: #1e88e5; color: #bbdefb; }

        .hidden { display: none !important; }
        
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            pointer-events: auto;
        }
        #joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            top: 50px;
            left: 50px;
        }
        @media (max-width: 768px) {
            #mobile-controls { display: block; }
            .score-box { font-size: 16px; padding: 5px 10px; }
            #timer-box { font-size: 24px; top: 10px; }
            h1 { font-size: 40px; }
            p { font-size: 16px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="timer-box">90</div>
        <div class="hud-row">
            <div id="score-p2" class="score-box">P2: 0</div>
            <div id="score-p3" class="score-box">P3: 0</div>
        </div>
        <div class="hud-row" style="align-items: flex-end;">
            <div id="score-p1" class="score-box">P1(You): 0</div>
            <div id="score-p4" class="score-box">P4: 0</div>
        </div>
    </div>

    <!-- Mobile Joystick -->
    <div id="mobile-controls">
        <div id="joystick-knob"></div>
    </div>

    <div id="overlay">
        <h1 id="overlay-title">PIXEL LAWN ARENA</h1>
        <p id="overlay-desc">
            Use <b>W, A, S, D</b> or <b>Arrow Keys</b> to move.<br>
            Grass takes <b>2 cuts</b> to clear. Watch out for hidden <b>Mines</b> after the 1st cut!<br>
            Collect blue <b>Energy</b> to boost your speed.
        </p>
        <button id="start-btn">PLAY</button>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    
    // UI Elements
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start-btn');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayDesc = document.getElementById('overlay-desc');
    const timerEl = document.getElementById('timer-box');
    const scoreEls = [
        document.getElementById('score-p1'),
        document.getElementById('score-p2'),
        document.getElementById('score-p3'),
        document.getElementById('score-p4')
    ];

    // Mobile joystick logic
    const joystickArea = document.getElementById('mobile-controls');
    const joystickKnob = document.getElementById('joystick-knob');
    let joystickActive = false;
    let joystickVec = { x: 0, y: 0 };

    joystickArea.addEventListener('touchstart', handleJoystickStart, {passive: false});
    joystickArea.addEventListener('touchmove', handleJoystickMove, {passive: false});
    joystickArea.addEventListener('touchend', handleJoystickEnd);
    joystickArea.addEventListener('touchcancel', handleJoystickEnd);

    function handleJoystickStart(e) { e.preventDefault(); joystickActive = true; updateJoystick(e.touches[0]); }
    function handleJoystickMove(e) { if(!joystickActive) return; e.preventDefault(); updateJoystick(e.touches[0]); }
    function handleJoystickEnd() { joystickActive = false; joystickVec = { x: 0, y: 0 }; joystickKnob.style.transform = `translate(0px, 0px)`; }
    function updateJoystick(touch) {
        const rect = joystickArea.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let dx = touch.clientX - centerX;
        let dy = touch.clientY - centerY;
        const maxDist = rect.width / 2;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
        joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickVec.x = dx / maxDist; joystickVec.y = dy / maxDist;
    }

    // Game Constants & Variables
    const TILE_SIZE = 40;
    let cols, rows;
    let grid = [];
    let entities = [];
    let particles = [];
    let items = [];
    let explosions = [];
    let gameState = 'menu';
    let gameTimer = 90;
    let lastTime = 0;
    let accumulator = 0;
    const TIME_STEP = 1000 / 60;

    // Colors
    const PALETTE = {
        dirt: '#8c6b4e',
        dirtDark: '#6b5038',
        grassBase: '#4CAF50',
        grassLight: '#81C784',
        grassDark: '#2E7D32',
        p1: '#e53935', p2: '#43a047', p3: '#fdd835', p4: '#1e88e5'
    };

    // Input Handling
    const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
    window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
    window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', resize);
    resize();

    // Classes
    class Item {
        constructor(r, c, type) {
            this.r = r;
            this.c = c;
            this.x = c * TILE_SIZE + TILE_SIZE/2;
            this.y = r * TILE_SIZE + TILE_SIZE/2;
            this.type = type; // 'mine' or 'booster'
            this.revealed = false;
            this.timer = 2 + Math.random() * 3; // 2 to 5 secs for mine
            this.active = true;
            this.flashPhase = 0;
            // Float animation offset for booster
            this.floatPhase = Math.random() * Math.PI * 2; 
        }

        update(dt) {
            if (!this.active) return;
            
            // Reveal item if grass is cut at least once (grid <= 1)
            if (!this.revealed && grid[this.r][this.c] <= 1) {
                this.revealed = true;
                // Pop effect
                spawnParticles(this.x, this.y, '#fff', '#ccc', 4);
            }

            if (this.revealed) {
                if (this.type === 'mine') {
                    this.timer -= dt;
                    this.flashPhase += dt * (6 - this.timer) * 4; // Flashes faster as it ticks down
                    if (this.timer <= 0) {
                        this.explode();
                    }
                } else if (this.type === 'booster') {
                    this.floatPhase += dt * 5;
                    // Check collision
                    entities.forEach(e => {
                        if (Math.hypot(e.x - this.x, e.y - this.y) < TILE_SIZE) {
                            e.applyBooster();
                            this.active = false;
                            spawnParticles(this.x, this.y, '#00bcd4', '#e0f7fa', 10);
                        }
                    });
                }
            }
        }

        explode() {
            this.active = false;
            explosions.push({x: this.x, y: this.y, radius: 0, maxRadius: TILE_SIZE * 2, life: 1});
            for(let i=0; i<15; i++) {
                particles.push(new Particle(this.x, this.y, '#ff9800', '#f44336', 150));
            }
            entities.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) < TILE_SIZE * 2) {
                    e.applyStun();
                }
            });
        }

        draw(ctx) {
            if (!this.active || !this.revealed) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            
            if (this.type === 'mine') {
                ctx.fillStyle = '#222';
                ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#795548';
                ctx.fillRect(-2, -14, 4, 6); // fuse
                // Flashing red center
                if (Math.sin(this.flashPhase) > 0) {
                    ctx.fillStyle = '#f44336';
                    ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
                }
            } else if (this.type === 'booster') {
                const yOffset = Math.sin(this.floatPhase) * 4;
                ctx.translate(0, yOffset);
                ctx.fillStyle = '#00bcd4';
                ctx.shadowColor = '#00bcd4';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(-4, -10); ctx.lineTo(6, -10);
                ctx.lineTo(1, 0); ctx.lineTo(6, 0);
                ctx.lineTo(-6, 12); ctx.lineTo(-2, 2);
                ctx.lineTo(-8, 2); ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }
    }

    class Entity {
        constructor(x, y, color, isPlayer = false, id = 0) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.baseSpeed = 220; 
            this.color = color;
            this.size = TILE_SIZE * 0.7;
            this.isPlayer = isPlayer;
            this.id = id;
            this.score = 0;
            this.facingX = 1;
            
            this.targetTile = null;
            this.rethinkTimer = Math.random(); 
            this.stuckTimer = 0;
            this.lastX = x;
            this.lastY = y;

            this.cutTimers = new Map(); // Tracks when a tile was last cut by this entity
            this.stunTimer = 0;
            this.buffTimer = 0;
        }

        update(dt) {
            // Handle Status Effects
            if (this.stunTimer > 0) {
                this.stunTimer -= dt;
                return; // Cannot move while stunned
            }

            let currentSpeed = this.baseSpeed;
            if (this.buffTimer > 0) {
                this.buffTimer -= dt;
                currentSpeed *= 1.6; // Speed boost multiplier
            }

            if (this.isPlayer) {
                this.handlePlayerInput();
            } else {
                this.handleAI(dt);
            }

            // Normalize velocity
            let mag = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (mag > 0) {
                this.vx = (this.vx / mag) * currentSpeed;
                this.vy = (this.vy / mag) * currentSpeed;
                this.facingX = this.vx > 0 ? 1 : -1;
            }

            this.x += this.vx * dt;
            this.y += this.vy * dt;

            // Boundaries
            const half = this.size / 2;
            if (this.x < half) this.x = half;
            if (this.y < half) this.y = half;
            if (this.x > canvas.width - half) this.x = canvas.width - half;
            if (this.y > canvas.height - half) this.y = canvas.height - half;

            this.checkGrassCollision();
        }

        applyStun() {
            this.stunTimer = 2.0;
            this.score = Math.max(0, this.score - 5); // Deduct penalty points
            this.scorePop('-5', '#f44336');
            updateScoreUI();
        }

        applyBooster() {
            this.buffTimer = 4.0;
        }

        scorePop(text, color) {
            // Quick visual feedback for points lost/gained
            let uiElement = scoreEls[this.id];
            uiElement.style.transform = 'scale(1.3)';
            uiElement.style.color = color;
            setTimeout(() => {
                uiElement.style.transform = 'scale(1)';
                uiElement.style.color = 'white'; // Revert to base, CSS takes over
            }, 300);
        }

        handlePlayerInput() {
            this.vx = 0; this.vy = 0;
            if (keys.w || keys.ArrowUp) this.vy -= 1;
            if (keys.s || keys.ArrowDown) this.vy += 1;
            if (keys.a || keys.ArrowLeft) this.vx -= 1;
            if (keys.d || keys.ArrowRight) this.vx += 1;
            if (joystickActive) { this.vx = joystickVec.x; this.vy = joystickVec.y; }
        }

        handleAI(dt) {
            this.rethinkTimer -= dt;
            
            if (Math.abs(this.x - this.lastX) < 1 && Math.abs(this.y - this.lastY) < 1) {
                this.stuckTimer += dt;
            } else {
                this.stuckTimer = 0;
            }
            this.lastX = this.x; this.lastY = this.y;

            if (this.rethinkTimer <= 0 || !this.targetTile || this.stuckTimer > 0.5) {
                this.rethinkTimer = 0.5 + Math.random() * 0.5;
                this.targetTile = this.findNearestGrass();
                
                if (this.stuckTimer > 0.5) {
                    this.vx = (Math.random() - 0.5);
                    this.vy = (Math.random() - 0.5);
                    this.stuckTimer = 0;
                    this.rethinkTimer = 0.5; 
                    return;
                }
            }

            if (this.targetTile) {
                const tx = this.targetTile.c * TILE_SIZE + TILE_SIZE/2;
                const ty = this.targetTile.r * TILE_SIZE + TILE_SIZE/2;
                this.vx = tx - this.x; this.vy = ty - this.y;
            } else {
                this.vx = 0; this.vy = 0;
            }
        }

        findNearestGrass() {
            let closest = null;
            let minDist = Infinity;
            
            let gc = Math.floor(this.x / TILE_SIZE);
            let gr = Math.floor(this.y / TILE_SIZE);
            let radius = 10;
            let startR = Math.max(0, gr - radius);
            let endR = Math.min(rows - 1, gr + radius);
            let startC = Math.max(0, gc - radius);
            let endC = Math.min(cols - 1, gc + radius);

            for (let r = startR; r <= endR; r++) {
                for (let c = startC; c <= endC; c++) {
                    if (grid[r][c] > 0) { // Look for any grass (1 or 2)
                        const tx = c * TILE_SIZE + TILE_SIZE/2;
                        const ty = r * TILE_SIZE + TILE_SIZE/2;
                        
                        let dangerPenalty = 0;
                        // Avoid revealed mines
                        for(let i=0; i<items.length; i++) {
                            let item = items[i];
                            if(item.active && item.type === 'mine' && item.revealed) {
                                if (Math.abs(item.r - r) <= 2 && Math.abs(item.c - c) <= 2) {
                                    dangerPenalty += 50000; // Big penalty for tiles near mines
                                }
                            }
                            // Bonus to seek boosters
                            if(item.active && item.type === 'booster' && item.revealed) {
                                if(item.r === r && item.c === c) dangerPenalty -= 5000;
                            }
                        }

                        const dist = Math.pow(tx - this.x, 2) + Math.pow(ty - this.y, 2) + (Math.random()*200) + dangerPenalty; 
                        
                        if (dist < minDist) {
                            minDist = dist;
                            closest = {r, c};
                        }
                    }
                }
            }
            return closest;
        }

        checkGrassCollision() {
            const c = Math.floor(this.x / TILE_SIZE);
            const r = Math.floor(this.y / TILE_SIZE);
            const now = Date.now();

            for(let i = -1; i <= 1; i++) {
                for(let j = -1; j <= 1; j++) {
                    const checkR = r + i;
                    const checkC = c + j;
                    if(checkR >= 0 && checkR < rows && checkC >= 0 && checkC < cols) {
                        if (grid[checkR][checkC] > 0) {
                            const tileCenterX = checkC * TILE_SIZE + TILE_SIZE/2;
                            const tileCenterY = checkR * TILE_SIZE + TILE_SIZE/2;
                            
                            const dist = Math.hypot(this.x - tileCenterX, this.y - tileCenterY);
                            if (dist < (this.size/2 + TILE_SIZE/3)) {
                                let key = `${checkR},${checkC}`;
                                let lastCut = this.cutTimers.get(key) || 0;
                                
                                // Cooldown prevents instant double-cut
                                if (now - lastCut > 500) {
                                    grid[checkR][checkC]--;
                                    this.cutTimers.set(key, now);
                                    
                                    // Score depends on stage of cut
                                    this.score += 1; 
                                    updateScoreUI();

                                    // Particles
                                    let color1 = grid[checkR][checkC] === 1 ? PALETTE.grassLight : PALETTE.dirt;
                                    spawnParticles(tileCenterX, tileCenterY, PALETTE.grassBase, color1, 8);
                                }
                            }
                        }
                    }
                }
            }
        }

        draw(ctx) {
            ctx.fillStyle = this.color;
            const s = this.size;
            
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Visual Status Effects
            if (this.stunTimer > 0) {
                ctx.filter = 'grayscale(80%)';
            } else if (this.buffTimer > 0) {
                ctx.shadowColor = '#00bcd4';
                ctx.shadowBlur = 15;
            }

            let wiggleY = 0;
            if (this.stunTimer <= 0 && (this.vx !== 0 || this.vy !== 0)) {
                wiggleY = Math.sin(Date.now() / 50) * 3;
            }

            // Shadow
            ctx.shadowBlur = 0; // Turn off glow for shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(-s/2 + 2, -s/2 + 5 + s, s, s*0.2);

            if (this.buffTimer > 0) { ctx.shadowBlur = 15; } // Turn back on for body

            // Body
            ctx.fillStyle = this.color;
            ctx.fillRect(-s/2, -s/2 + wiggleY, s, s * 0.8);
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(-s/2, -s/2 + wiggleY, s, s*0.2);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(-s/2, -s/2 + wiggleY + s*0.6, s, s*0.2);

            // Eyes (Closed if stunned)
            ctx.fillStyle = 'white';
            const eyeOffX = this.facingX * (s*0.1);
            
            if (this.stunTimer > 0) {
                ctx.fillStyle = '#111';
                ctx.fillRect(-s/4 + eyeOffX, -s/4 + wiggleY + s*0.1, s*0.2, 3);
                ctx.fillRect(s/8 + eyeOffX, -s/4 + wiggleY + s*0.1, s*0.2, 3);
            } else {
                ctx.fillRect(-s/4 + eyeOffX, -s/4 + wiggleY, s*0.2, s*0.2);
                ctx.fillRect(s/8 + eyeOffX, -s/4 + wiggleY, s*0.2, s*0.2);
                ctx.fillStyle = 'black';
                ctx.fillRect(-s/4 + s*0.1 + eyeOffX, -s/4 + s*0.1 + wiggleY, s*0.1, s*0.1);
                ctx.fillRect(s/8 + s*0.1 + eyeOffX, -s/4 + s*0.1 + wiggleY, s*0.1, s*0.1);
            }

            ctx.filter = 'none';
            ctx.shadowBlur = 0;

            // Stun stars above head
            if (this.stunTimer > 0) {
                ctx.fillStyle = '#ffeb3b';
                let t = Date.now() / 150;
                ctx.fillRect(Math.cos(t) * 15, -s/2 - 10 + Math.sin(t) * 5, 5, 5);
                ctx.fillRect(Math.cos(t + Math.PI) * 15, -s/2 - 10 + Math.sin(t + Math.PI) * 5, 5, 5);
            }

            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color1, color2, velMod = 100) {
            this.x = x + (Math.random() - 0.5) * TILE_SIZE/2;
            this.y = y + (Math.random() - 0.5) * TILE_SIZE/2;
            this.vx = (Math.random() - 0.5) * velMod * 2;
            this.vy = (Math.random() - 0.5) * velMod * 2 - (velMod/2);
            this.life = 1.0;
            this.decay = 1.5 + Math.random();
            this.size = 3 + Math.random() * 5;
            this.color = Math.random() > 0.5 ? color1 : color2;
        }
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vy += 400 * dt; 
            this.life -= this.decay * dt;
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function spawnParticles(x, y, c1, c2, count) {
        for(let i=0; i<count; i++) particles.push(new Particle(x, y, c1, c2));
    }

    // Initialization
    function initGame() {
        resize();
        cols = Math.ceil(canvas.width / TILE_SIZE);
        rows = Math.ceil(canvas.height / TILE_SIZE);
        
        grid = [];
        items = [];
        explosions = [];
        particles = [];

        for (let r = 0; r < rows; r++) {
            let row = [];
            for (let c = 0; c < cols; c++) {
                if (r > 1 && r < rows - 2 && c > 1 && c < cols - 2) {
                    row.push(2); // 2 = full grass, 1 = half grass, 0 = dirt
                    
                    // Spawn Items (Don't spawn too close to starting corners)
                    let isCorner = (r < 4 && c < 4) || (r < 4 && c > cols-5) || 
                                   (r > rows-5 && c < 4) || (r > rows-5 && c > cols-5);
                    if (!isCorner) {
                        let rand = Math.random();
                        if (rand < 0.06) {
                            items.push(new Item(r, c, 'mine'));
                        } else if (rand < 0.10) {
                            items.push(new Item(r, c, 'booster'));
                        }
                    }
                } else {
                    row.push(0);
                }
            }
            grid.push(row);
        }

        entities = [];
        const s = TILE_SIZE * 2;
        entities.push(new Entity(s, canvas.height - s, PALETTE.p1, true, 0));
        entities.push(new Entity(s, s, PALETTE.p2, false, 1));
        entities.push(new Entity(canvas.width - s, s, PALETTE.p3, false, 2));
        entities.push(new Entity(canvas.width - s, canvas.height - s, PALETTE.p4, false, 3));

        gameTimer = 90;
        updateScoreUI();
        timerEl.innerText = gameTimer;
        
        gameState = 'playing';
        overlay.classList.add('hidden');
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function updateScoreUI() {
        if(entities.length === 0) return;
        scoreEls[0].innerText = `P1(You): ${entities[0].score}`;
        scoreEls[1].innerText = `P2: ${entities[1].score}`;
        scoreEls[2].innerText = `P3: ${entities[2].score}`;
        scoreEls[3].innerText = `P4: ${entities[3].score}`;
    }

    function endGame() {
        gameState = 'end';
        let maxScore = -1;
        let winnerId = -1;
        entities.forEach(e => {
            if(e.score > maxScore) { maxScore = e.score; winnerId = e.id; }
        });

        let title = "TIME'S UP!";
        let desc = "";
        
        if (winnerId === 0) {
            title = "YOU WIN!";
            desc = `Amazing job! You scored ${maxScore} points.`;
            overlayTitle.style.textShadow = "4px 4px 0 " + PALETTE.p1;
        } else {
            let botColors = ["", "Green", "Yellow", "Blue"];
            title = "YOU LOSE!";
            desc = `The ${botColors[winnerId]} bot won with ${maxScore} points. Your score: ${entities[0].score}.`;
            let wColor = [PALETTE.p1, PALETTE.p2, PALETTE.p3, PALETTE.p4][winnerId];
            overlayTitle.style.textShadow = "4px 4px 0 " + wColor;
        }

        overlayTitle.innerText = title;
        overlayDesc.innerHTML = desc;
        startBtn.innerText = "PLAY AGAIN";
        overlay.classList.remove('hidden');
    }

    // Main Loop
    function update(dt) {
        if (gameState !== 'playing') return;

        const prevTimer = Math.ceil(gameTimer);
        gameTimer -= dt;
        if (Math.ceil(gameTimer) !== prevTimer) {
            timerEl.innerText = Math.max(0, Math.ceil(gameTimer));
        }

        if (gameTimer <= 0) { endGame(); return; }

        let grassLeft = false;
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                if(grid[r][c] > 0) { grassLeft = true; break; }
            }
            if(grassLeft) break;
        }
        if(!grassLeft) { endGame(); return; }

        entities.forEach(e => e.update(dt));
        
        items.forEach(i => i.update(dt));
        items = items.filter(i => i.active);

        explosions.forEach(ex => {
            ex.radius += dt * 300;
            ex.life -= dt * 3;
        });
        explosions = explosions.filter(ex => ex.life > 0);

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(dt);
            if (particles[i].life <= 0) particles.splice(i, 1);
        }
    }

    function draw() {
        ctx.fillStyle = PALETTE.dirt;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Grid Map
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const x = c * TILE_SIZE;
                const y = r * TILE_SIZE;

                if (grid[r][c] === 2) {
                    // Full Grass
                    ctx.fillStyle = PALETTE.grassBase;
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = PALETTE.grassLight;
                    ctx.fillRect(x + 4, y + 4, 8, 8);
                    ctx.fillRect(x + 20, y + 8, 8, 8);
                    ctx.fillStyle = PALETTE.grassDark;
                    ctx.fillRect(x + TILE_SIZE - 12, y + TILE_SIZE - 12, 8, 8);
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(x, y + TILE_SIZE - 4, TILE_SIZE, 4);
                    ctx.fillRect(x + TILE_SIZE - 4, y, 4, TILE_SIZE);
                } else if (grid[r][c] === 1) {
                    // Half cut (Stubble)
                    if ((r+c)%2 === 0) {
                        ctx.fillStyle = PALETTE.dirtDark;
                        ctx.fillRect(x + TILE_SIZE/2 - 4, y + TILE_SIZE/2 - 4, 8, 8);
                    }
                    ctx.fillStyle = PALETTE.grassBase;
                    ctx.fillRect(x + 4, y + 4, 12, 12);
                    ctx.fillRect(x + TILE_SIZE/2 + 2, y + TILE_SIZE/2 + 2, 10, 10);
                } else {
                    // Dirt
                    if ((r+c)%2 === 0) {
                        ctx.fillStyle = PALETTE.dirtDark;
                        ctx.fillRect(x + TILE_SIZE/2 - 4, y + TILE_SIZE/2 - 4, 8, 8);
                    }
                }
            }
        }

        // Draw Items (Mines / Boosters)
        items.forEach(i => i.draw(ctx));

        // Draw Mine Explosions
        explosions.forEach(ex => {
            ctx.fillStyle = `rgba(255, 87, 34, ${ex.life})`;
            ctx.beginPath();
            ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw Particles
        particles.forEach(p => p.draw(ctx));

        // Draw Entities (sort by Y)
        entities.sort((a, b) => a.y - b.y);
        entities.forEach(e => e.draw(ctx));
    }

    function gameLoop(timestamp) {
        if (gameState !== 'playing') return;
        let dt = timestamp - lastTime;
        lastTime = timestamp;
        if (dt > 100) dt = 100;
        accumulator += dt;

        while (accumulator >= TIME_STEP) {
            update(TIME_STEP / 1000); 
            accumulator -= TIME_STEP;
        }

        draw();
        requestAnimationFrame(gameLoop);
    }

    startBtn.addEventListener('click', initGame);

    resize();
    ctx.fillStyle = PALETTE.dirt;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

</script>
</body>
</html>