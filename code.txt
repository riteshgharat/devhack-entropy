import React from 'react';
import { Background } from './components/Background';
import { PixelButton } from './components/PixelButton';
import { PixelCharacter, PixelStickman } from './components/PixelCharacter';
import { PlayerStats } from './components/PlayerStats';
import { SplashScreen } from './components/SplashScreen';
import { MultiplayerLobby } from './components/MultiplayerLobby';
import { motion, AnimatePresence } from 'motion/react';
import { Settings, Volume2, Sun, Moon, User, Zap, Pencil, Gamepad2, Activity, Vibrate } from 'lucide-react';
import { PixelCard } from './components/PixelCard';
import { GameArena } from './components/GameArena';
import { gameClient } from './services/gameClient';
import { Room } from 'colyseus.js';
import {
  AuthScreen,
  AuthGatePrompt,
  PlayerProfileBadge,
  getStoredSession,
  clearSession,
  type UserProfile,
} from './components/AuthScreen';

const AVATAR_COLORS = [
  '#ef4444', '#3b82f6', '#22c55e', '#eab308',
  '#a855f7', '#f97316', '#ec4899', '#06b6d4',
  '#14b8a6', '#f43f5e', '#8b5cf6', '#84cc16',
];

function App() {
  const [showSettings, setShowSettings] = React.useState(false);
  const [showSplash, setShowSplash] = React.useState(true);
  const [nightMode, setNightMode] = React.useState(true); // default NIGHT
  const [showMultiplayer, setShowMultiplayer] = React.useState(false);
  const [showEditProfile, setShowEditProfile] = React.useState(false);
  const [characterColor, setCharacterColor] = React.useState(localStorage.getItem('playerColor') || '#ef4444');
  const [activeRoom, setActiveRoom] = React.useState<Room | null>(null);
  const [displayName, setDisplayName] = React.useState(localStorage.getItem('displayName') || `Player_${Math.floor(Math.random() * 1000)}`);
  const [showFps, setShowFps] = React.useState(localStorage.getItem('showFps') === 'true');
  const [screenShake, setScreenShake] = React.useState(localStorage.getItem('screenShake') !== 'false');
  const [playerId] = React.useState(() => {
    let id = localStorage.getItem('playerId');
    if (!id) {
      id = `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      localStorage.setItem('playerId', id);
    }
    return id;
  });

  /* ‚îÄ‚îÄ Auth state ‚îÄ‚îÄ */
  const [currentUser, setCurrentUser] = React.useState<UserProfile | null>(() => getStoredSession());
  const [showAuthGate, setShowAuthGate] = React.useState(false);
  const [showAuthScreen, setShowAuthScreen] = React.useState(false);
  const [authInitialTab, setAuthInitialTab] = React.useState<'signin' | 'signup'>('signin');
  const [isMatchmaking, setIsMatchmaking] = React.useState(false);

  React.useEffect(() => {
    localStorage.setItem('displayName', displayName);
  }, [displayName]);

  React.useEffect(() => {
    localStorage.setItem('playerColor', characterColor);
  }, [characterColor]);

  React.useEffect(() => {
    const token = sessionStorage.getItem('reconnectionToken');
    if (token) {
      gameClient.reconnect(token).then((room) => {
        setActiveRoom(room);
        setShowSplash(false);
      }).catch((err) => {
        console.error("Failed to reconnect", err);
        sessionStorage.removeItem('reconnectionToken');
      });
    }
  }, []);

  const handleJoinRoom = (room: Room) => {
    setIsMatchmaking(true);
    // Smooth transition to arena
    setTimeout(() => {
      setActiveRoom(room);
      sessionStorage.setItem('reconnectionToken', room.reconnectionToken);
      setShowMultiplayer(false);
      setIsMatchmaking(false);
    }, 2000);
  };

  const handleLeaveRoom = () => {
    gameClient.leave();
    setActiveRoom(null);
    sessionStorage.removeItem('reconnectionToken');
  };

  /* ‚îÄ‚îÄ Auth flow: clicked "Start Game" or "Multiplayer" ‚îÄ‚îÄ */
  const handlePlayAction = () => {
    if (currentUser) {
      setShowMultiplayer(true);
    } else {
      setShowAuthGate(true);
    }
  };

  /* ‚îÄ‚îÄ Auth callbacks ‚îÄ‚îÄ */
  const handleAuthComplete = (user: UserProfile) => {
    setCurrentUser(user);
    setDisplayName(user.username);
    setCharacterColor(user.avatarColor);
    setShowAuthScreen(false);
    setShowAuthGate(false);
    setTimeout(() => setShowMultiplayer(true), 300);
  };

  const handleLogout = () => {
    clearSession();
    setCurrentUser(null);
  };

  const handleAuthGateSignIn = () => {
    setShowAuthGate(false);
    setAuthInitialTab('signin');
    setShowAuthScreen(true);
  };

  const handleAuthGateSignUp = () => {
    setShowAuthGate(false);
    setAuthInitialTab('signup');
    setShowAuthScreen(true);
  };

  const handleAuthGateGuest = () => {
    setShowAuthGate(false);
    const guestName = `Guest_${Math.floor(Math.random() * 9000 + 1000)}`;
    const COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#f97316', '#ec4899', '#06b6d4'];
    const guestColor = COLORS[Math.floor(Math.random() * COLORS.length)];
    const guestProfile: UserProfile = {
      id: playerId,
      username: guestName,
      isGuest: true,
      avatarColor: guestColor,
      level: 1,
      xp: 0,
      wins: 0,
      matches: 0,
      createdAt: new Date().toISOString(),
    };
    localStorage.setItem('chaos_arena_session', JSON.stringify(guestProfile));
    localStorage.setItem('displayName', guestName);
    localStorage.setItem('playerColor', guestColor);
    setCurrentUser(guestProfile);
    setDisplayName(guestName);
    setCharacterColor(guestColor);
    setTimeout(() => setShowMultiplayer(true), 300);
  };

  if (showSplash) {
    return <SplashScreen onComplete={() => setShowSplash(false)} />;
  }

  return (
    <div className="min-h-screen relative flex flex-col">
      <Background nightMode={nightMode} />

      {activeRoom ? (
        <div className="relative z-10 flex-1">
          <header className="pt-8 text-center">
            <h1 className={`font-display text-4xl uppercase tracking-tighter ${nightMode ? 'text-indigo-300' : 'text-yellow-400'}`}>
              CHAOS ARENA
            </h1>
          </header>
          <GameArena
            room={activeRoom}
            nightMode={nightMode}
            setNightMode={setNightMode}
            onLeave={handleLeaveRoom}
          />
        </div>
      ) : (
        <>

          {/* Day/Night Toggle ‚Äî fixed top-left */}
      <motion.button
        onClick={() => setNightMode(!nightMode)}
        className={`fixed top-4 left-4 z-50 w-14 h-14 border-4 flex items-center justify-center transition-colors duration-500 cursor-pointer pixel-corners ${nightMode
          ? 'bg-indigo-600 border-indigo-800 hover:bg-indigo-500'
          : 'bg-amber-400 border-amber-600 hover:bg-amber-300'
          }`}
        whileHover={{ scale: 1.1, rotate: 15 }}
        whileTap={{ scale: 0.9 }}
        title={nightMode ? 'Switch to Day' : 'Switch to Night'}
      >
        <AnimatePresence mode="wait">
          {nightMode ? (
            <motion.div
              key="moon"
              initial={{ rotate: -90, opacity: 0, scale: 0 }}
              animate={{ rotate: 0, opacity: 1, scale: 1 }}
              exit={{ rotate: 90, opacity: 0, scale: 0 }}
              transition={{ duration: 0.3 }}
            >
              <Moon size={24} className="text-yellow-200" fill="currentColor" />
            </motion.div>
          ) : (
            <motion.div
              key="sun"
              initial={{ rotate: 90, opacity: 0, scale: 0 }}
              animate={{ rotate: 0, opacity: 1, scale: 1 }}
              exit={{ rotate: -90, opacity: 0, scale: 0 }}
              transition={{ duration: 0.3 }}
            >
              <Sun size={24} className="text-amber-800" />
            </motion.div>
          )}
        </AnimatePresence>
      </motion.button>

          {/* Day/Night label indicator */}
          <motion.div
            className={`fixed top-5 left-20 z-50 font-display text-[10px] uppercase tracking-widest px-3 py-1 border-2 transition-colors duration-500 ${nightMode
              ? 'bg-indigo-900/80 border-indigo-600 text-indigo-300'
              : 'bg-amber-100/80 border-amber-500 text-amber-800'
              }`}
            initial={{ x: -20, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            transition={{ delay: 0.3 }}
          >
            {nightMode ? 'üåô Night' : '‚òÄÔ∏è Day'}
          </motion.div>

          {/* ‚ïê‚ïê‚ïê Player Profile Badge (top-right) ‚ïê‚ïê‚ïê */}
          {currentUser && (
            <PlayerProfileBadge
              user={currentUser}
              nightMode={nightMode}
              onLogout={handleLogout}
              onEditProfile={() => setShowEditProfile(true)}
            />
          )}

          {/* Header / Logo */}
          <header className="relative z-10 pt-12 pb-6 text-center">
            <motion.h1
              initial={{ y: -100, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              transition={{ type: "spring", bounce: 0.5 }}
              className={`font-display text-6xl md:text-8xl drop-shadow-[4px_4px_0_rgba(0,0,0,1)] tracking-tighter transition-colors duration-700 ${nightMode ? 'text-indigo-300' : 'text-yellow-400'
                }`}
              style={{
                textShadow: nightMode
                  ? '4px 4px 0 #000, -2px -2px 0 #6366f1'
                  : '4px 4px 0 #000, -2px -2px 0 #ef4444'
              }}
            >
              CHAOS ARENA
            </motion.h1>
            <motion.p
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.5 }}
              className={`font-body text-2xl drop-shadow-md mt-2 transition-colors duration-700 ${nightMode ? 'text-slate-300' : 'text-white'
                }`}
            >
              BRAWL. PIXEL. WIN.
            </motion.p>
          </header>

          {/* Main Content */}
          <main className="flex-1 relative z-10 container mx-auto px-4 py-8">
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 items-center h-full">

              {/* Left: Character ‚Äî clickable to change color */}
              <div className="flex justify-center lg:justify-end order-2 lg:order-1">
                <PixelCharacter
                  color={characterColor}
                  onColorChange={setCharacterColor}
                />
              </div>

              {/* Center: Menu */}
              <div className="flex flex-col gap-6 items-center justify-center order-1 lg:order-2">
                <PixelButton
                  size="lg"
                  className="w-64 text-xl tracking-widest animate-pulse"
                  onClick={handlePlayAction}
                >
                  Start Game
                </PixelButton>

                <PixelButton
                  variant="secondary"
                  size="md"
                  className="w-64"
                  onClick={handlePlayAction}
                >
                  Multiplayer
                </PixelButton>

                <PixelButton
                  variant="accent"
                  size="md"
                  className="w-64"
                  onClick={() => setShowSettings(true)}
                >
                  Settings
                </PixelButton>

                {/* Sign In / Sign Up button if not logged in */}
                {!currentUser && (
                  <motion.div
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: 0.6 }}
                  >
                    <PixelButton
                      variant="secondary"
                      size="sm"
                      className="w-64"
                      onClick={() => { setAuthInitialTab('signin'); setShowAuthScreen(true); }}
                    >
                      üîë Sign In / Sign Up
                    </PixelButton>
                  </motion.div>
                )}
              </div>

              {/* Right: Player Stats */}
              <div className="flex justify-center lg:justify-start order-3">
                <PlayerStats nightMode={nightMode} />
              </div>
            </div>
          </main>

          {/* Footer */}
          <footer className={`relative z-10 p-4 text-center font-body text-lg transition-colors duration-700 ${nightMode ? 'text-slate-400' : 'text-white/80'
            }`}>
            <p>v1.0.4-beta ‚Ä¢ Server Status: <span className="text-green-400">ONLINE</span></p>
          </footer>
        </>
      )}

      {/* Multiplayer Lobby Modal */}
      <AnimatePresence>
        {showMultiplayer && (
          <MultiplayerLobby
            nightMode={nightMode}
            characterColor={characterColor}
            playerId={playerId}
            displayName={displayName}
            onClose={() => setShowMultiplayer(false)}
            onJoin={handleJoinRoom}
          />
        )}
      </AnimatePresence>

      {/* ‚ïê‚ïê‚ïê Auth Gate Prompt ("You're not logged in!") ‚ïê‚ïê‚ïê */}
      <AnimatePresence>
        {showAuthGate && (
          <AuthGatePrompt
            nightMode={nightMode}
            onSignIn={handleAuthGateSignIn}
            onSignUp={handleAuthGateSignUp}
            onGuest={handleAuthGateGuest}
            onClose={() => setShowAuthGate(false)}
          />
        )}
      </AnimatePresence>

      {/* ‚ïê‚ïê‚ïê Full Auth Screen (Sign In / Sign Up) ‚ïê‚ïê‚ïê */}
      <AnimatePresence>
        {showAuthScreen && (
          <AuthScreen
            nightMode={nightMode}
            onAuth={handleAuthComplete}
            onClose={() => setShowAuthScreen(false)}
            initialTab={authInitialTab}
          />
        )}
      </AnimatePresence>

      {/* ‚ïê‚ïê‚ïê Cinematic "Entering Arena" Overlay ‚ïê‚ïê‚ïê */}
      <AnimatePresence>
        {isMatchmaking && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-[100] bg-black flex flex-col items-center justify-center overflow-hidden"
          >
            {/* Background Zooming Grid */}
            <motion.div 
              initial={{ scale: 1 }}
              animate={{ scale: 1.5 }}
              transition={{ duration: 4, ease: "easeOut" }}
              className="absolute inset-0 opacity-20 pointer-events-none"
              style={{
                backgroundImage: `linear-gradient(${nightMode ? '#312e81' : '#047857'} 1px, transparent 1px), linear-gradient(90deg, ${nightMode ? '#312e81' : '#047857'} 1px, transparent 1px)`,
                backgroundSize: '40px 40px'
              }}
            />

            <motion.div
              initial={{ scale: 0.5, opacity: 0, y: 20 }}
              animate={{ scale: 1.5, opacity: 1, y: 0 }}
              transition={{ 
                duration: 1.5, 
                ease: [0.16, 1, 0.3, 1],
                delay: 0.2
              }}
              className="relative z-10 text-center"
            >
              {/* Character Unsheathing Sword */}
              <div className="mb-12 relative flex items-center justify-center">
                <motion.div
                  initial={{ rotate: -10 }}
                  animate={{ rotate: 0 }}
                  transition={{ duration: 0.5, repeat: Infinity, repeatType: 'reverse' }}
                >
                  <PixelStickman 
                    color={currentUser?.color || '#3b82f6'} 
                    scale={1.8} 
                    weapon="sword"
                    swordState={isMatchmaking ? 'unsheathing' : 'idle'} 
                  />
                </motion.div>

                {/* Impact Flash behind character */}
                <motion.div 
                  initial={{ scale: 0, opacity: 0 }}
                  animate={{ scale: [0, 2, 0], opacity: [0, 0.4, 0] }}
                  transition={{ delay: 0.8, duration: 0.5 }}
                  className="absolute inset-0 bg-white rounded-full blur-3xl"
                />
              </div>

              {/* Cinematic Text Overlay */}
              <motion.div
                initial={{ opacity: 0, y: 30 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 1.2, duration: 0.8 }}
              >
                <h2 className={`font-display text-3xl md:text-5xl uppercase tracking-[0.4em] mb-2 ${nightMode ? 'text-indigo-300' : 'text-yellow-400'}`}
                    style={{ textShadow: '0 0 20px currentColor' }}>
                  Entering into Arena
                </h2>
                
                {/* Loading Status Bar */}
                <div className="w-64 h-1 bg-white/10 mx-auto mt-6 relative overflow-hidden">
                  <motion.div 
                    initial={{ x: '-100%' }}
                    animate={{ x: '100%' }}
                    transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                    className={`absolute inset-0 w-1/2 ${nightMode ? 'bg-indigo-500' : 'bg-yellow-400'}`}
                  />
                </div>
              </motion.div>
            </motion.div>

            {/* Final Warp Effect */}
            <motion.div 
              initial={{ opacity: 0 }}
              animate={{ opacity: [0, 1, 0] }}
              transition={{ delay: 2.8, duration: 0.4 }}
              className="absolute inset-0 bg-white z-[110] pointer-events-none"
            />
          </motion.div>
        )}
      </AnimatePresence>

      {/* Settings Modal */}
      {showSettings && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
          <motion.div
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            className="w-full max-w-md"
          >
            <PixelCard title="Settings" className="mx-4" nightMode={nightMode}>
              <div className="space-y-5 mt-4">

                {/* Edit Profile shortcut */}
                <button
                  onClick={() => { setShowSettings(false); setShowEditProfile(true); }}
                  className={`w-full flex items-center gap-3 px-4 py-3 border-2 font-display text-xs uppercase transition-colors cursor-pointer ${nightMode
                    ? 'border-indigo-500 bg-indigo-900/30 text-indigo-300 hover:bg-indigo-900/50'
                    : 'border-indigo-400 bg-indigo-50 text-indigo-700 hover:bg-indigo-100'
                    }`}
                >
                  <Pencil size={14} />
                  <span>Edit Profile</span>
                  <span className="ml-auto text-[9px] opacity-60">Name, Avatar</span>
                </button>

                {/* Audio */}
                <div className="space-y-2">
                  <label className={`font-display text-xs uppercase flex items-center gap-2 transition-colors duration-700 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                    <Volume2 size={14} /> Music & SFX
                  </label>
                  <div className="flex gap-3 items-center">
                    <span className={`font-body text-xs ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>üîá</span>
                    <input type="range" defaultValue={80} className={`flex-1 h-4 rounded-none appearance-none cursor-pointer ${nightMode ? 'accent-indigo-500 bg-slate-600' : 'accent-green-500 bg-slate-200'}`} />
                    <span className={`font-body text-xs ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>üîä</span>
                  </div>
                </div>

                {/* Theme toggle */}
                <div className="space-y-2">
                  <label className={`font-display text-xs uppercase flex items-center gap-2 transition-colors duration-700 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                    {nightMode ? <Moon size={14} /> : <Sun size={14} />} Theme
                  </label>
                  <button
                    onClick={() => setNightMode(!nightMode)}
                    className={`w-full py-2 border-2 font-display text-xs uppercase transition-colors duration-300 cursor-pointer ${nightMode
                      ? 'border-amber-500 bg-amber-900/30 text-amber-300 hover:bg-amber-900/50'
                      : 'border-indigo-500 bg-indigo-100 text-indigo-700 hover:bg-indigo-200'
                      }`}
                  >
                    {nightMode ? '‚òÄÔ∏è Switch to Day' : 'üåô Switch to Night'}
                  </button>
                </div>

                {/* FPS Counter toggle */}
                <div className="flex items-center justify-between">
                  <label className={`font-display text-xs uppercase flex items-center gap-2 transition-colors duration-700 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                    <Activity size={14} /> Show FPS Counter
                  </label>
                  <button
                    onClick={() => { setShowFps(!showFps); localStorage.setItem('showFps', String(!showFps)); }}
                    className={`w-12 h-6 border-2 relative transition-colors cursor-pointer ${showFps
                      ? (nightMode ? 'bg-indigo-600 border-indigo-400' : 'bg-green-500 border-green-600')
                      : (nightMode ? 'bg-slate-700 border-slate-600' : 'bg-slate-200 border-slate-300')
                    }`}
                  >
                    <div className={`absolute top-0.5 w-4 h-4 transition-all ${showFps ? 'left-6' : 'left-0.5'} ${nightMode ? 'bg-white' : 'bg-white'}`} />
                  </button>
                </div>

                {/* Screen Shake toggle */}
                <div className="flex items-center justify-between">
                  <label className={`font-display text-xs uppercase flex items-center gap-2 transition-colors duration-700 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                    <Vibrate size={14} /> Screen Shake
                  </label>
                  <button
                    onClick={() => { setScreenShake(!screenShake); localStorage.setItem('screenShake', String(!screenShake)); }}
                    className={`w-12 h-6 border-2 relative transition-colors cursor-pointer ${screenShake
                      ? (nightMode ? 'bg-indigo-600 border-indigo-400' : 'bg-green-500 border-green-600')
                      : (nightMode ? 'bg-slate-700 border-slate-600' : 'bg-slate-200 border-slate-300')
                    }`}
                  >
                    <div className={`absolute top-0.5 w-4 h-4 transition-all ${screenShake ? 'left-6' : 'left-0.5'} ${nightMode ? 'bg-white' : 'bg-white'}`} />
                  </button>
                </div>

                {/* Controls reference */}
                <div className="space-y-2">
                  <label className={`font-display text-xs uppercase flex items-center gap-2 transition-colors duration-700 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                    <Gamepad2 size={14} /> Controls
                  </label>
                  <div className={`grid grid-cols-2 gap-2 p-3 border-2 font-body text-xs ${nightMode
                    ? 'bg-slate-700/50 border-slate-600 text-slate-300'
                    : 'bg-slate-50 border-slate-200 text-slate-600'
                  }`}>
                    <div>‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è <span className="opacity-60">Move</span></div>
                    <div>SPACE <span className="opacity-60">Action</span></div>
                    <div>E <span className="opacity-60">Interact</span></div>
                    <div>ESC <span className="opacity-60">Pause</span></div>
                  </div>
                </div>

                <div className={`flex justify-end pt-4 border-t-2 transition-colors duration-700 ${nightMode ? 'border-slate-600' : 'border-slate-100'}`}>
                  <PixelButton variant="secondary" size="sm" onClick={() => setShowSettings(false)}>
                    Close
                  </PixelButton>
                </div>
              </div>
            </PixelCard>
          </motion.div>
        </div>
      )}

      {/* ‚ïê‚ïê‚ïê Edit Profile Modal ‚ïê‚ïê‚ïê */}
      <AnimatePresence>
        {showEditProfile && (
          <motion.div
            className="fixed inset-0 z-[60] flex items-center justify-center bg-black/70 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <motion.div
              initial={{ scale: 0.8, opacity: 0, y: 30 }}
              animate={{ scale: 1, opacity: 1, y: 0 }}
              exit={{ scale: 0.8, opacity: 0, y: 30 }}
              transition={{ type: 'spring', bounce: 0.3 }}
              className="w-full max-w-md mx-4"
            >
              <PixelCard title="Edit Profile" className="" nightMode={nightMode}>
                <div className="space-y-5 mt-4">

                  {/* Avatar preview */}
                  <div className="flex flex-col items-center gap-3">
                    <motion.div
                      className="w-20 h-20 border-4 border-black/30 flex items-center justify-center relative"
                      style={{ backgroundColor: characterColor }}
                      animate={{ y: [0, -4, 0] }}
                      transition={{ duration: 1.2, repeat: Infinity, ease: 'easeInOut' }}
                    >
                      <div className="absolute top-3 left-3 w-3 h-3 bg-white" />
                      <div className="absolute top-3 right-3 w-3 h-3 bg-white" />
                      <div className="absolute bottom-3 left-1/2 -translate-x-1/2 w-6 h-2 bg-black/40" />
                    </motion.div>
                    <p className={`font-display text-xs uppercase ${nightMode ? 'text-indigo-300' : 'text-indigo-600'}`}>
                      {currentUser?.isGuest ? 'üëª Guest' : `‚öîÔ∏è Level ${currentUser?.level || 1}`}
                    </p>
                  </div>

                  {/* Username */}
                  <div className="space-y-2">
                    <label className={`font-display text-xs uppercase flex items-center gap-2 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                      <User size={14} /> Display Name
                    </label>
                    <input
                      type="text"
                      value={displayName}
                      onChange={(e) => {
                        const val = e.target.value;
                        setDisplayName(val);
                        if (currentUser) {
                          const updated = { ...currentUser, username: val };
                          setCurrentUser(updated);
                          localStorage.setItem('chaos_arena_session', JSON.stringify(updated));
                          localStorage.setItem('displayName', val);
                        }
                      }}
                      className={`w-full p-3 border-4 font-display text-sm outline-none transition-colors ${nightMode
                        ? 'bg-slate-700 border-slate-500 text-white focus:border-indigo-400'
                        : 'bg-white border-slate-300 text-slate-800 focus:border-indigo-500'
                      }`}
                      maxLength={16}
                      placeholder="Enter your name..."
                    />
                  </div>

                  {/* Avatar Color */}
                  <div className="space-y-2">
                    <label className={`font-display text-xs uppercase flex items-center gap-2 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                      <Zap size={14} /> Avatar Color
                    </label>
                    <div className="flex gap-2 flex-wrap">
                      {AVATAR_COLORS.map((c) => (
                        <motion.button
                          key={c}
                          onClick={() => {
                            setCharacterColor(c);
                            localStorage.setItem('playerColor', c);
                            if (currentUser) {
                              const updated = { ...currentUser, avatarColor: c };
                              setCurrentUser(updated);
                              localStorage.setItem('chaos_arena_session', JSON.stringify(updated));
                            }
                          }}
                          whileHover={{ scale: 1.2 }}
                          whileTap={{ scale: 0.8 }}
                          className={`w-9 h-9 border-3 cursor-pointer transition-all ${characterColor === c
                            ? 'border-white shadow-[0_0_12px_rgba(255,255,255,0.5)] scale-110'
                            : nightMode
                              ? 'border-slate-600 hover:border-slate-400'
                              : 'border-slate-300 hover:border-slate-500'
                          }`}
                          style={{ backgroundColor: c }}
                        >
                          {characterColor === c && (
                            <motion.div
                              initial={{ scale: 0 }}
                              animate={{ scale: 1 }}
                              className="w-full h-full flex items-center justify-center"
                            >
                              <div className="w-2 h-2 bg-white" />
                            </motion.div>
                          )}
                        </motion.button>
                      ))}
                    </div>
                  </div>

                  {/* Stats row */}
                  {currentUser && (
                    <div className={`grid grid-cols-3 gap-0 border-2 ${nightMode ? 'border-slate-600' : 'border-slate-200'}`}>
                      <div className={`p-2 text-center border-r-2 ${nightMode ? 'border-slate-600' : 'border-slate-200'}`}>
                        <p className={`font-display text-base ${nightMode ? 'text-yellow-400' : 'text-yellow-600'}`}>{currentUser.wins}</p>
                        <p className={`font-display text-[7px] uppercase ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>Wins</p>
                      </div>
                      <div className={`p-2 text-center border-r-2 ${nightMode ? 'border-slate-600' : 'border-slate-200'}`}>
                        <p className={`font-display text-base ${nightMode ? 'text-slate-300' : 'text-slate-700'}`}>{currentUser.matches}</p>
                        <p className={`font-display text-[7px] uppercase ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>Matches</p>
                      </div>
                      <div className="p-2 text-center">
                        <p className={`font-display text-base ${nightMode ? 'text-indigo-300' : 'text-indigo-600'}`}>{currentUser.level}</p>
                        <p className={`font-display text-[7px] uppercase ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>Level</p>
                      </div>
                    </div>
                  )}

                  {/* Save / Close */}
                  <div className={`flex gap-3 pt-4 border-t-2 ${nightMode ? 'border-slate-600' : 'border-slate-100'}`}>
                    <PixelButton variant="primary" size="md" className="flex-1 text-xs" onClick={() => setShowEditProfile(false)}>
                      ‚úì Save Changes
                    </PixelButton>
                    <PixelButton variant="secondary" size="md" className="text-xs" onClick={() => setShowEditProfile(false)}>
                      Cancel
                    </PixelButton>
                  </div>
                </div>
              </PixelCard>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

export default App;
app.tsx 



Pixelcharacter.tsx:-import React, { useState } from 'react';
import { motion, AnimatePresence } from 'motion/react';

/* Color palette ‚Äî matches the splash screen stickmen */
export const STICKMAN_COLORS = [
  { name: 'Red', hex: '#ef4444' },
  { name: 'Blue', hex: '#3b82f6' },
  { name: 'Green', hex: '#22c55e' },
  { name: 'Yellow', hex: '#eab308' },
  { name: 'Purple', hex: '#a855f7' },
  { name: 'Orange', hex: '#f97316' },
  { name: 'Pink', hex: '#ec4899' },
  { name: 'Cyan', hex: '#06b6d4' },
];

interface PixelCharacterProps {
  color?: string;
  onColorChange?: (color: string) => void;
}

/* ‚îÄ‚îÄ Same PixelStickman as splash screen ‚îÄ‚îÄ */
export interface StickmanProps {
    color: string;
    eyeColor?: string;
    scale?: number;
    weapon?: 'sword' | 'shield' | 'none';
    crown?: boolean;
    halfBody?: boolean;
    pointing?: 'left' | 'right' | 'none';
    swordState?: 'idle' | 'unsheathed' | 'unsheathing';
}

export const PixelStickman: React.FC<StickmanProps> = ({
    color,
    eyeColor = '#fff',
    scale = 1,
    weapon = 'none',
    crown = false,
    halfBody = false,
    pointing = 'none',
    swordState = 'idle',
}) => {
    const s = (v: number) => `${v * scale}px`;
    return (
        <div className="relative" style={{ width: s(56), height: s(90), imageRendering: 'pixelated' }}>
            {/* Crown for leader */}
            {crown && (
                <div className="absolute left-1/2 -translate-x-1/2" style={{ top: s(-10), zIndex: 20 }}>
                    <div style={{
                        width: s(24), height: s(10),
                        background: 'linear-gradient(180deg, #fbbf24 0%, #d97706 100%)',
                        border: `${s(2)} solid #92400e`,
                        clipPath: 'polygon(0% 100%, 0% 30%, 25% 0%, 50% 40%, 75% 0%, 100% 30%, 100% 100%)',
                    }} />
                </div>
            )}

            {/* Head */}
            <div className="absolute left-1/2 -translate-x-1/2" style={{
                top: 0, width: s(22), height: s(22),
                backgroundColor: color,
                border: `${s(3)} solid #111`,
                boxShadow: `inset ${s(-3)} ${s(-3)} 0 0 rgba(0,0,0,0.25), inset ${s(2)} ${s(2)} 0 0 rgba(255,255,255,0.15)`,
            }}>
                {/* Eyes */}
                <div className="absolute" style={{
                    top: s(6), left: s(3), width: s(4), height: s(4),
                    backgroundColor: eyeColor,
                    boxShadow: `${s(7)} 0 0 0 ${eyeColor}`,
                }} />
                {/* Mouth grin */}
                <div className="absolute" style={{
                    bottom: s(3), left: s(4), width: s(14), height: s(2),
                    backgroundColor: '#111',
                    boxShadow: `${s(-4)} 0 0 0 #111, ${s(4)} 0 0 0 #111`,
                }} />
            </div>

            {/* Neck */}
            <div className="absolute left-1/2 -translate-x-1/2" style={{
                top: s(22), width: s(8), height: s(4), backgroundColor: color,
            }} />

            {/* Body */}
            <div className="absolute left-1/2 -translate-x-1/2" style={{
                top: s(26), width: s(16), height: s(26),
                backgroundColor: color,
                border: `${s(3)} solid #111`,
                boxShadow: `inset ${s(-3)} ${s(-3)} 0 0 rgba(0,0,0,0.25), inset ${s(2)} ${s(2)} 0 0 rgba(255,255,255,0.1)`,
            }}>
                {/* Belt */}
                <div style={{
                    position: 'absolute', bottom: 0, left: 0, right: 0,
                    height: s(5), backgroundColor: 'rgba(0,0,0,0.4)',
                }} />
                {/* Belt buckle */}
                <div style={{
                    position: 'absolute', bottom: s(1), left: '50%',
                    transform: 'translateX(-50%)',
                    width: s(4), height: s(4), backgroundColor: '#fbbf24',
                    border: `${s(1)} solid #92400e`,
                }} />
            </div>

            {/* Left Arm */}
            <motion.div 
                className="absolute" 
                style={{
                    top: s(26), left: s(-2), width: s(9), height: s(20),
                    backgroundColor: color,
                    border: `${s(2)} solid #111`,
                    boxShadow: `inset ${s(-2)} ${s(-2)} 0 0 rgba(0,0,0,0.2)`,
                    transformOrigin: 'top center',
                }}
                animate={
                    pointing === 'left' ? { rotate: 90, x: -5 } : 
                    swordState === 'unsheathing' ? { rotate: 120 } : 
                    swordState === 'unsheathed' ? { rotate: 140 } : 
                    { rotate: 0, x: 0 }
                }
            />

            {/* Right Arm */}
            <motion.div 
                className="absolute" 
                style={{
                    top: s(26), right: s(-2), width: s(9), height: s(20),
                    backgroundColor: color,
                    border: `${s(2)} solid #111`,
                    boxShadow: `inset ${s(-2)} ${s(-2)} 0 0 rgba(0,0,0,0.2)`,
                    transformOrigin: 'top center',
                }}
                animate={
                    pointing === 'right' ? { rotate: -90, x: 5 } : 
                    swordState === 'unsheathing' ? { rotate: -40 } : 
                    swordState === 'unsheathed' ? { rotate: -60 } : 
                    { rotate: 0, x: 0 }
                }
            />

            {/* Weapon - Sword */}
            {weapon === 'sword' && (
                <motion.div 
                    className="absolute" 
                    style={{ 
                        top: s(18), 
                        right: s(-14), 
                        width: s(8), 
                        height: s(40), 
                        zIndex: 20,
                        transformOrigin: 'bottom center'
                    }}
                    animate={
                        swordState === 'unsheathing' ? { y: [-20, -40], opacity: [0, 1], rotate: [45, 0] } :
                        swordState === 'unsheathed' ? { y: -40, opacity: 1, scale: 1.2 } :
                        { y: 0, opacity: 0, rotate: 45 }
                    }
                >
                    {/* Blade */}
                    <div style={{
                        position: 'absolute', top: 0, left: '50%', transform: 'translateX(-50%)',
                        width: s(4), height: s(28),
                        background: 'linear-gradient(180deg, #e2e8f0 0%, #94a3b8 50%, #64748b 100%)',
                        border: `${s(1)} solid #334155`,
                        clipPath: 'polygon(20% 0, 80% 0, 100% 100%, 0 100%)',
                    }} />
                    {/* Guard */}
                    <div style={{
                        position: 'absolute', top: s(26), left: 0,
                        width: s(8), height: s(4),
                        backgroundColor: '#d97706',
                        border: `${s(1)} solid #92400e`,
                    }} />
                    {/* Handle */}
                    <div style={{
                        position: 'absolute', top: s(30), left: '50%', transform: 'translateX(-50%)',
                        width: s(3), height: s(10),
                        backgroundColor: '#92400e',
                        border: `${s(1)} solid #451a03`,
                    }} />
                </motion.div>
            )}

            {/* Weapon - Shield */}
            {weapon === 'shield' && (
                <div className="absolute" style={{ top: s(22), left: s(-20), width: s(18), height: s(22), zIndex: 20 }}>
                    <div style={{
                        width: '100%', height: '100%',
                        background: 'linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)',
                        border: `${s(3)} solid #1e3a8a`,
                        clipPath: 'polygon(0 0, 100% 0, 100% 65%, 50% 100%, 0 65%)',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                    }}>
                        <div style={{ width: s(6), height: s(6), backgroundColor: '#fbbf24', border: `${s(1)} solid #92400e` }} />
                    </div>
                </div>
            )}

            {/* Legs - Only if not half-body */}
            {!halfBody && (
                <>
                    {/* Left Leg */}
                    <div className="absolute" style={{
                        top: s(52), left: s(11), width: s(11), height: s(26),
                        backgroundColor: color,
                        border: `${s(2)} solid #111`,
                        filter: 'brightness(0.8)',
                    }} />

                    {/* Right Leg */}
                    <div className="absolute" style={{
                        top: s(52), right: s(11), width: s(11), height: s(26),
                        backgroundColor: color,
                        border: `${s(2)} solid #111`,
                        filter: 'brightness(0.8)',
                    }} />

                    {/* Boots */}
                    <div className="absolute" style={{
                        top: s(76), left: s(7), width: s(16), height: s(9),
                        backgroundColor: '#1c1917',
                        border: `${s(2)} solid #000`,
                        boxShadow: `inset ${s(2)} 0 0 0 rgba(255,255,255,0.1)`,
                    }} />
                    <div className="absolute" style={{
                        top: s(76), right: s(7), width: s(16), height: s(9),
                        backgroundColor: '#1c1917',
                        border: `${s(2)} solid #000`,
                        boxShadow: `inset ${s(2)} 0 0 0 rgba(255,255,255,0.1)`,
                    }} />
                </>
            )}
        </div>
    );
};

export const PixelCharacter: React.FC<PixelCharacterProps> = ({
  color: externalColor,
  onColorChange,
}) => {
  const [colorIndex, setColorIndex] = useState(0);
  const [showPalette, setShowPalette] = useState(false);

  const currentColor = externalColor || STICKMAN_COLORS[colorIndex].hex;
  const currentName =
    STICKMAN_COLORS.find((c) => c.hex === currentColor)?.name || 'Custom';

  const cycleColor = () => {
    const nextIndex = (colorIndex + 1) % STICKMAN_COLORS.length;
    setColorIndex(nextIndex);
    onColorChange?.(STICKMAN_COLORS[nextIndex].hex);
    setShowPalette(true);
    // Hide palette after 2.5s
    setTimeout(() => setShowPalette(false), 2500);
  };

  return (
    <div className="relative w-80 h-96 flex items-center justify-center">
      {/* Clickable character */}
      <motion.div
        className="cursor-pointer relative"
        onClick={cycleColor}
        whileHover={{ scale: 1.08 }}
        whileTap={{ scale: 0.92, rotate: -5 }}
      >
        {/* Idle bounce animation */}
        <motion.div
          animate={{ y: [0, -10, 0] }}
          transition={{
            duration: 2,
            repeat: Infinity,
            ease: 'easeInOut',
          }}
        >
          <PixelStickman color={currentColor} scale={2.8} />
        </motion.div>

        {/* Color glow under feet */}
        <motion.div
          className="absolute -bottom-4 left-1/2 -translate-x-1/2 rounded-full"
          style={{
            width: '110px',
            height: '18px',
            backgroundColor: currentColor,
            opacity: 0.3,
            filter: 'blur(10px)',
          }}
          animate={{ opacity: [0.2, 0.5, 0.2], scale: [0.9, 1.1, 0.9] }}
          transition={{ duration: 2, repeat: Infinity }}
        />

        {/* Shadow */}
        <div className="absolute -bottom-5 left-1/2 -translate-x-1/2 w-28 h-4 bg-black/25 rounded-full blur-sm" />
      </motion.div>

      {/* Speech bubble */}
      <motion.div
        initial={{ opacity: 0, scale: 0 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ delay: 1, duration: 0.5 }}
        className="absolute -top-2 -right-2 z-10"
      >
        <motion.div
          className="bg-white border-3 p-2.5 px-3 relative"
          style={{ borderColor: currentColor, borderWidth: '3px' }}
          animate={{ y: [0, -3, 0] }}
          transition={{ duration: 2, repeat: Infinity, ease: 'easeInOut' }}
        >
          <p className="font-display text-[9px] text-black whitespace-nowrap">
            üé® TAP TO
          </p>
          <p className="font-display text-[9px] whitespace-nowrap" style={{ color: currentColor }}>
            RECOLOR!
          </p>
          <div
            className="absolute bottom-0 left-3 w-3 h-3 bg-white -translate-x-1/2 translate-y-1/2 rotate-45"
            style={{ borderRight: `3px solid ${currentColor}`, borderBottom: `3px solid ${currentColor}` }}
          />
        </motion.div>
      </motion.div>

      {/* Color name popup */}
      <AnimatePresence>
        {showPalette && (
          <motion.div
            initial={{ y: 20, opacity: 0, scale: 0.8 }}
            animate={{ y: 0, opacity: 1, scale: 1 }}
            exit={{ y: -10, opacity: 0, scale: 0.8 }}
            className="absolute -bottom-10 left-1/2 -translate-x-1/2 px-4 py-1 border-2 border-black z-20"
            style={{ backgroundColor: currentColor }}
          >
            <p className="font-display text-[10px] text-white whitespace-nowrap"
              style={{ textShadow: '1px 1px 0 #000' }}
            >
              {currentName.toUpperCase()}
            </p>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Small color dots row indicating available colors */}
      <div className="absolute -bottom-16 left-1/2 -translate-x-1/2 flex gap-1.5">
        {STICKMAN_COLORS.map((c, i) => (
          <motion.div
            key={c.hex}
            className="border border-black/40 cursor-pointer"
            style={{
              width: '10px',
              height: '10px',
              backgroundColor: c.hex,
              opacity: c.hex === currentColor ? 1 : 0.4,
              boxShadow: c.hex === currentColor ? `0 0 6px ${c.hex}` : 'none',
            }}
            whileHover={{ scale: 1.5 }}
            onClick={(e) => {
              e.stopPropagation();
              setColorIndex(i);
              onColorChange?.(c.hex);
              setShowPalette(true);
              setTimeout(() => setShowPalette(false), 2500);
            }}
          />
        ))}
      </div>
    </div>
  );
};

























PixelButton.tsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'motion/react';
import { PixelStickman, STICKMAN_COLORS } from './PixelCharacter';

interface PixelButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'accent' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  className?: string;
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
  disabled?: boolean;
}

export const PixelButton = ({
  variant = 'primary',
  size = 'md',
  children,
  className = '',
  ...props
}: PixelButtonProps) => {
  const [isHovered, setIsHovered] = useState(false);

  const baseStyles = "relative font-display uppercase transition-all duration-200 active:scale-95 focus:outline-none pixel-corners";

  const variants = {
    primary: "bg-green-400 text-green-900 hover:bg-green-300 border-b-4 border-green-700 active:border-b-0 active:translate-y-1 shadow-[4px_4px_0_rgba(0,0,0,0.2)]",
    secondary: "bg-blue-400 text-blue-900 hover:bg-blue-300 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1 shadow-[4px_4px_0_rgba(0,0,0,0.2)]",
    accent: "bg-yellow-400 text-yellow-900 hover:bg-yellow-300 border-b-4 border-yellow-700 active:border-b-0 active:translate-y-1 shadow-[4px_4px_0_rgba(0,0,0,0.2)]",
    danger: "bg-red-400 text-red-900 hover:bg-red-300 border-b-4 border-red-700 active:border-b-0 active:translate-y-1 shadow-[4px_4px_0_rgba(0,0,0,0.2)]",
  };

  const sizes = {
    sm: "text-xs py-2 px-4",
    md: "text-sm py-3 px-6",
    lg: "text-base py-4 px-8",
  };

  const randomColor = STICKMAN_COLORS[Math.floor(Math.random() * STICKMAN_COLORS.length)].hex;

  return (
    <div className="relative inline-block">
      {/* ‚îÄ‚îÄ Hovering Character (Half Body) ‚îÄ‚îÄ */}
      <AnimatePresence>
        {isHovered && !props.disabled && (
          <motion.div
            initial={{ opacity: 0, x: -40, y: '-50%', scale: 0.8 }}
            animate={{ opacity: 1, x: -60, y: '-50%', scale: 1 }}
            exit={{ opacity: 0, x: -30, y: '-50%', scale: 0.8 }}
            className="absolute top-1/2 left-0 z-20 pointer-events-none"
          >
            <motion.div
              animate={{ x: [0, -5, 0] }}
              transition={{ duration: 0.5, repeat: Infinity }}
            >
              <PixelStickman color={randomColor} scale={0.7} halfBody={true} pointing="right" />
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      <motion.button
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
        whileHover={{ scale: 1.05 }}
        whileTap={{ scale: 0.95 }}
        className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${props.disabled ? 'opacity-50 cursor-not-allowed grayscale pointer-events-none' : ''} ${className}`}
        {...(props as any)}
      >
        <span className="relative z-10">{children}</span>
      </motion.button>
    </div>
  );
};





Gamestats.tsx;-
import { Schema, MapSchema, ArraySchema, type } from "@colyseus/schema";
import { PlayerState } from "./PlayerState";
import { GrassState } from "./GrassState";

export class GameState extends Schema {
  /** Map of sessionId ‚Üí PlayerState */
  @type({ map: PlayerState }) players = new MapSchema<PlayerState>();

  /** Active grass elements */
  @type([GrassState]) grasses = new ArraySchema<GrassState>();

  /** Has the match started? */
  @type("boolean") matchStarted: boolean = false;

  /** Is the match over? */
  @type("boolean") matchEnded: boolean = false;

  /** Time remaining in seconds */
  @type("float32") matchTimer: number = 60;

  /** Current arena boundary */
  @type("float32") arenaBoundaryX: number = 800;
  @type("float32") arenaBoundaryY: number = 600;

  /** Session ID of the match winner */
  @type("string") winnerId: string = "";

  /** Countdown seconds before match starts (0 = go) */
  @type("uint8") countdown: number = 0;

  /** Last event label (broadcast to clients for UI) */
  @type("string") lastEvent: string = "";

  /** Session ID of the room owner */
  @type("string") ownerId: string = "";
}





PlayerStats.tsx:-import { Schema, type } from "@colyseus/schema";

export class PlayerState extends Schema {
  /** Horizontal position (world units) */
  @type("float32") x: number = 0;

  /** Vertical position (world units) */
  @type("float32") y: number = 0;

  /** Horizontal velocity */
  @type("float32") velocityX: number = 0;

  /** Vertical velocity */
  @type("float32") velocityY: number = 0;

  /** Grass collected */
  @type("uint16") score: number = 0;

  /** Speed multiplier (e.g., from speed booster) */
  @type("float32") speedMultiplier: number = 1;

  /** Time left for stun effect (e.g., from bomb or rocket) */
  @type("float32") stunTimer: number = 0;

  /** Display name shown in-game */
  @type("string") displayName: string = "";

  /** Unique player ID */
  @type("string") playerId: string = "";

  /** Player color */
  @type("string") color: string = "#ffffff";

  /** Is the player ready to start? */
  @type("boolean") isReady: boolean = false;
}










Gameroom.tsx:-import { Room, Client } from "colyseus";
import { GameState } from "../schemas/GameState";
import { PlayerState } from "../schemas/PlayerState";
import { GrassState } from "../schemas/GrassState";
import {
  ARENA_WIDTH,
  ARENA_HEIGHT,
  MAX_PLAYERS,
  MIN_PLAYERS,
  PLAYER_SPEED,
  MAX_VELOCITY,
  SPAWN_MARGIN,
  MATCH_COUNTDOWN,
  MATCH_RESET_DELAY,
  TICK_RATE,
  MATCH_DURATION,
  GRASS_RADIUS,
  PLAYER_RADIUS,
} from "../utils/constants";
import { saveMatchResult, savePlayerStats } from "../../../db/matchHistory";

interface MoveInput {
  dx: number;
  dy: number;
}

const TILE_SIZE = 64;
const COLS = 12;
const ROWS = 8;

// Corner spawn positions (offset from corners by SPAWN_MARGIN)
const CORNER_SPAWNS = [
  { x: SPAWN_MARGIN, y: SPAWN_MARGIN },                                       // top-left
  { x: ARENA_WIDTH - SPAWN_MARGIN, y: SPAWN_MARGIN },                         // top-right
  { x: SPAWN_MARGIN, y: ARENA_HEIGHT - SPAWN_MARGIN },                        // bottom-left
  { x: ARENA_WIDTH - SPAWN_MARGIN, y: ARENA_HEIGHT - SPAWN_MARGIN },          // bottom-right
  { x: ARENA_WIDTH / 2, y: SPAWN_MARGIN },                                    // top-center
  { x: ARENA_WIDTH / 2, y: ARENA_HEIGHT - SPAWN_MARGIN },                     // bottom-center
  { x: SPAWN_MARGIN, y: ARENA_HEIGHT / 2 },                                   // left-center
  { x: ARENA_WIDTH - SPAWN_MARGIN, y: ARENA_HEIGHT / 2 },                     // right-center
];

// Power-up counts
const BOMB_COUNT = 5;
const ROCKET_COUNT = 5;
const SPEED_COUNT = 5;

export class GameRoom extends Room<GameState> {
  private countdownInterval: ReturnType<typeof setInterval> | null = null;
  private resetTimeout: ReturnType<typeof setTimeout> | null = null;
  /** Tracks when each grass was converted from phase 1‚Üí2 (grass.id ‚Üí timestamp) */
  private grassConvertTime: Map<string, number> = new Map();

  async onCreate(options: any) {
    if (options.customRoomId) {
      this.roomId = options.customRoomId;
    }
    this.state = new GameState();
    this.maxClients = MAX_PLAYERS;

    this.state.arenaBoundaryX = ARENA_WIDTH;
    this.state.arenaBoundaryY = ARENA_HEIGHT;

    this.onMessage("move", (client: Client, data: MoveInput) => {
      this.handleMove(client, data);
    });

    this.onMessage("ready", (client: Client) => {
      const player = this.state.players.get(client.sessionId);
      if (player && !this.state.matchStarted) {
        player.isReady = !player.isReady;
        console.log(`üì£ ${player.displayName} is ${player.isReady ? "READY" : "NOT READY"}`);
        this.tryStartCountdown();
      }
    });

    this.setSimulationInterval((deltaTime: number) => {
      this.update(deltaTime);
    }, 1000 / TICK_RATE);

    console.log(`üèüÔ∏è  GameRoom created | Room ID: ${this.roomId}`);
  }

  onJoin(client: Client, options: any) {
    const player = new PlayerState();

    // Spawn at corners
    const spawnIndex = this.state.players.size % CORNER_SPAWNS.length;
    const spawn = CORNER_SPAWNS[spawnIndex];
    player.x = spawn.x;
    player.y = spawn.y;
    player.score = 0;
    player.displayName =
      options?.displayName || `Player_${client.sessionId.slice(0, 4)}`;
    player.playerId = options?.playerId || client.sessionId;

    const colors = ["#ef4444", "#3b82f6", "#22c55e", "#eab308", "#a855f7", "#ec4899", "#14b8a6", "#f97316"];
    player.color = options?.color || colors[this.state.players.size % colors.length];

    this.state.players.set(client.sessionId, player);

    // First player becomes the owner
    if (this.state.players.size === 1) {
      this.state.ownerId = client.sessionId;
    }

    console.log(
      `‚úÖ ${player.displayName} joined | ` +
      `Session: ${client.sessionId} | ` +
      `Players: ${this.state.players.size}/${MAX_PLAYERS}`
    );

    this.tryStartCountdown();
  }

  onLeave(client: Client, _consented?: boolean) {
    const player = this.state.players.get(client.sessionId);
    if (!player) return;

    console.log(
      `‚ùå ${player.displayName} left | Session: ${client.sessionId}`
    );

    this.state.players.delete(client.sessionId);

    if (this.state.matchStarted && !this.state.matchEnded) {
      if (this.state.players.size < MIN_PLAYERS) {
        this.endMatch();
      }
    } else {
      // If owner left, reassign owner
      if (this.state.ownerId === client.sessionId && this.state.players.size > 0) {
        const nextOwner = this.state.players.keys().next().value;
        this.state.ownerId = nextOwner || "";
      }
      this.tryStartCountdown();
    }
  }

  onDispose() {
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    if (this.resetTimeout) clearTimeout(this.resetTimeout);
    console.log(`üóëÔ∏è  GameRoom disposed | Room ID: ${this.roomId}`);
  }

  private handleMove(client: Client, data: MoveInput) {
    const player = this.state.players.get(client.sessionId);
    if (!player || !this.state.matchStarted || this.state.matchEnded) return;
    if (player.stunTimer > 0) return;

    const dx = Math.sign(data.dx || 0);
    const dy = Math.sign(data.dy || 0);

    player.velocityX = dx * PLAYER_SPEED * player.speedMultiplier;
    player.velocityY = dy * PLAYER_SPEED * player.speedMultiplier;
  }

  private update(deltaTime: number) {
    const dt = deltaTime / 1000;

    if (!this.state.matchStarted || this.state.matchEnded) return;

    this.state.matchTimer -= dt;
    if (this.state.matchTimer <= 0) {
      this.state.matchTimer = 0;
      this.endMatch();
      return;
    }

    this.state.players.forEach((player: PlayerState, sessionId: string) => {
      if (player.stunTimer > 0) {
        player.stunTimer -= dt;
        if (player.stunTimer <= 0) {
          player.stunTimer = 0;
        }
      }

      if (player.stunTimer <= 0) {
        player.x += player.velocityX * dt;
        player.y += player.velocityY * dt;

        const speed = Math.sqrt(
          player.velocityX * player.velocityX +
          player.velocityY * player.velocityY
        );
        if (speed > MAX_VELOCITY * player.speedMultiplier) {
          const scale = (MAX_VELOCITY * player.speedMultiplier) / speed;
          player.velocityX *= scale;
          player.velocityY *= scale;
        }

        player.velocityX *= 0.9;
        player.velocityY *= 0.9;
        if (Math.abs(player.velocityX) < 1) player.velocityX = 0;
        if (Math.abs(player.velocityY) < 1) player.velocityY = 0;

        player.x = Math.max(PLAYER_RADIUS, Math.min(this.state.arenaBoundaryX - PLAYER_RADIUS, player.x));
        player.y = Math.max(PLAYER_RADIUS, Math.min(this.state.arenaBoundaryY - PLAYER_RADIUS, player.y));
      }

      // ‚îÄ‚îÄ TWO-PHASE GRASS COLLECTION (time-based delay) ‚îÄ‚îÄ
      const now = Date.now();

      for (let i = this.state.grasses.length - 1; i >= 0; i--) {
        const grass = this.state.grasses[i];
        const dx = player.x - grass.x;
        const dy = player.y - grass.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        const collisionDist = PLAYER_RADIUS + (grass.phase === 1 ? GRASS_RADIUS : GRASS_RADIUS * 0.6);

        if (dist < collisionDist) {
          if (grass.phase === 1) {
            // Phase 1 ‚Üí Phase 2: Big grass becomes small grass ‚Äî 2 points
            player.score += 2;
            grass.phase = 2;

            // Record conversion time ‚Äî small grass won't be collectible for 500ms
            this.grassConvertTime.set(grass.id, now);

            this.broadcast("grass_collected", {
              id: grass.id,
              x: grass.x,
              y: grass.y,
              playerId: sessionId,
            });
          } else if (grass.phase === 2) {
            // Only allow collection if 500ms has passed since conversion
            const convertTime = this.grassConvertTime.get(grass.id) || 0;
            if (now - convertTime < 500) continue; // still in cooldown

            // Phase 2: Small grass collected ‚Üí remove it ‚Äî 1 point
            const powerUp = grass.powerUp;
            this.state.grasses.splice(i, 1);
            this.grassConvertTime.delete(grass.id);

            if (powerUp === "bomb") {
              player.stunTimer = 3;
              this.state.lastEvent = `${player.displayName} stepped on a Bomb!`;
            } else if (powerUp === "rocket") {
              this.state.lastEvent = `${player.displayName} launched a Rocket!`;
              this.state.players.forEach((p, id) => {
                if (id !== sessionId) {
                  p.stunTimer = 3;
                }
              });
            } else if (powerUp === "speed") {
              player.speedMultiplier = 2;
              this.state.lastEvent = `${player.displayName} found a Speed Booster!`;
              setTimeout(() => {
                if (this.state.players.has(sessionId)) {
                  this.state.players.get(sessionId)!.speedMultiplier = 1;
                }
              }, 5000);
            }
            player.score += 1;

            this.broadcast("small_grass_collected", {
              id: grass.id,
              x: grass.x,
              y: grass.y,
              powerUp,
              playerId: sessionId,
            });
          }
          break; // Only collect ONE grass per tick per player
        }
      }
    });

    // Check if all grass collected (both phases)
    if (this.state.grasses.length === 0) {
      this.endMatch();
    }
  }

  private tryStartCountdown() {
    if (this.state.matchStarted || this.countdownInterval) return;
    
    // Check if at least MIN_PLAYERS are in the room
    if (this.state.players.size < MIN_PLAYERS) {
      // If countdown was running and someone left, cancel it
      return;
    }

    // Check if everyone is ready
    let allReady = true;
    this.state.players.forEach(p => {
      if (!p.isReady) allReady = false;
    });

    if (!allReady) {
      // If countdown was starting but someone unreadied, cancel it (handled by checking interval existence)
      return;
    }

    console.log(`‚è≥ Everyone is READY! Countdown starting...`);
    this.state.countdown = MATCH_COUNTDOWN;

    this.countdownInterval = setInterval(() => {
      // Double check everyone is still ready during countdown
      let stillReady = true;
      this.state.players.forEach(p => {
        if (!p.isReady) stillReady = false;
      });

      if (!stillReady || this.state.players.size < MIN_PLAYERS) {
        console.log("‚ö†Ô∏è Countdown canceled: someone unreadied or left.");
        if (this.countdownInterval) clearInterval(this.countdownInterval);
        this.countdownInterval = null;
        this.state.countdown = 0;
        return;
      }

      this.state.countdown--;
      console.log(`‚è≥ ${this.state.countdown}...`);

      if (this.state.countdown <= 0) {
        if (this.countdownInterval) {
          clearInterval(this.countdownInterval);
          this.countdownInterval = null;
        }
        this.startMatch();
      }
    }, 1000);
  }

  private startMatch() {
    this.state.matchStarted = true;
    this.state.matchEnded = false;
    this.state.matchTimer = MATCH_DURATION;
    this.state.winnerId = "";
    this.state.lastEvent = "Match Started!";

    this.state.arenaBoundaryX = ARENA_WIDTH;
    this.state.arenaBoundaryY = ARENA_HEIGHT;

    // Clear existing
    while (this.state.grasses.length > 0) {
      this.state.grasses.pop();
    }

    // Build grass grid (12x8 = 96 tiles)
    const allPositions: { row: number; col: number }[] = [];
    for (let row = 0; row < ROWS; row++) {
      for (let col = 0; col < COLS; col++) {
        allPositions.push({ row, col });
      }
    }

    // Randomly assign power-ups to 15 of the 96 tiles
    const shuffled = [...allPositions].sort(() => Math.random() - 0.5);
    const powerUpMap = new Map<string, string>();
    for (let i = 0; i < BOMB_COUNT; i++) {
      const pos = shuffled[i];
      powerUpMap.set(`${pos.row}_${pos.col}`, "bomb");
    }
    for (let i = BOMB_COUNT; i < BOMB_COUNT + ROCKET_COUNT; i++) {
      const pos = shuffled[i];
      powerUpMap.set(`${pos.row}_${pos.col}`, "rocket");
    }
    for (let i = BOMB_COUNT + ROCKET_COUNT; i < BOMB_COUNT + ROCKET_COUNT + SPEED_COUNT; i++) {
      const pos = shuffled[i];
      powerUpMap.set(`${pos.row}_${pos.col}`, "speed");
    }

    // Create all 96 grass tiles as phase 1 (big) with hidden power-ups
    for (let row = 0; row < ROWS; row++) {
      for (let col = 0; col < COLS; col++) {
        const grass = new GrassState();
        grass.id = `grass_${row}_${col}`;
        grass.x = col * TILE_SIZE + TILE_SIZE / 2;
        grass.y = row * TILE_SIZE + TILE_SIZE / 2;
        grass.phase = 1;
        grass.powerUp = powerUpMap.get(`${row}_${col}`) || "";
        this.state.grasses.push(grass);
      }
    }

    // Spawn players at corners
    let spawnIdx = 0;
    this.state.players.forEach((player: PlayerState) => {
      player.score = 0;
      player.speedMultiplier = 1;
      player.stunTimer = 0;
      player.velocityX = 0;
      player.velocityY = 0;
      const spawn = CORNER_SPAWNS[spawnIdx % CORNER_SPAWNS.length];
      player.x = spawn.x;
      player.y = spawn.y;
      spawnIdx++;
    });

    console.log(`üéÆ Match started! ${this.state.players.size} players, ${this.state.grasses.length} grass tiles.`);
    this.broadcast("match_start", { playerCount: this.state.players.size });
  }

  private endMatch() {
    this.state.matchEnded = true;

    let winnerId = "";
    let winnerName = "";
    let maxScore = -1;
    let isDraw = false;

    this.state.players.forEach((player: PlayerState, sessionId: string) => {
      if (player.score > maxScore) {
        maxScore = player.score;
        winnerId = sessionId;
        winnerName = player.displayName;
        isDraw = false;
      } else if (player.score === maxScore) {
        isDraw = true;
      }
    });

    if (isDraw) {
      winnerId = "";
      winnerName = "Nobody";
    }

    this.state.winnerId = winnerId;

    console.log(
      isDraw
        ? `üèÜ Draw ‚Äî tied at ${maxScore}!`
        : `üèÜ ${winnerName} wins with ${maxScore}!`
    );

    this.broadcast("match_end", {
      winnerId,
      winnerName,
      maxScore,
      isDraw,
    });

    const playerStatsToSave: { id: string, displayName: string, isWinner: boolean, score: number }[] = [];
    this.state.players.forEach((player: PlayerState, sessionId: string) => {
      playerStatsToSave.push({
        id: player.playerId || sessionId,
        displayName: player.displayName,
        isWinner: !isDraw && sessionId === winnerId,
        score: player.score
      });
    });

    savePlayerStats(playerStatsToSave).catch((err) => console.warn(`‚ö†Ô∏è  Failed to save player stats: ${err.message}`));

    saveMatchResult({
      roomId: this.roomId,
      winnerId,
      winnerName,
      playerCount: this.state.players.size,
      matchDuration: MATCH_DURATION - this.state.matchTimer,
      isDraw,
    }).catch((err) => console.warn(`‚ö†Ô∏è  Failed to save match: ${err.message}`));

    this.resetTimeout = setTimeout(() => {
      this.resetMatch();
    }, MATCH_RESET_DELAY);
  }

  private resetMatch() {
    this.state.matchStarted = false;
    this.state.matchEnded = false;
    this.state.matchTimer = MATCH_DURATION;
    this.state.winnerId = "";
    this.state.countdown = 0;
    this.state.lastEvent = "";

    while (this.state.grasses.length > 0) {
      this.state.grasses.pop();
    }

    let spawnIdx = 0;
    this.state.players.forEach((player: PlayerState) => {
      player.score = 0;
      player.speedMultiplier = 1;
      player.stunTimer = 0;
      player.velocityX = 0;
      player.velocityY = 0;
      player.isReady = false; // Reset ready status for next match
      const spawn = CORNER_SPAWNS[spawnIdx % CORNER_SPAWNS.length];
      player.x = spawn.x;
      player.y = spawn.y;
      spawnIdx++;
    });

    console.log(`üîÑ Room reset. ${this.state.players.size} players ready.`);
    this.broadcast("match_reset", { playerCount: this.state.players.size });

    this.tryStartCountdown();
  }
}





Gamrearena.tsx:-import React, { useEffect, useRef, useState, useCallback } from 'react';
import { Room } from 'colyseus.js';
import { motion, AnimatePresence } from 'motion/react';
import { PixelCard } from './PixelCard';
import { PixelButton } from './PixelButton';
import { Trophy, Timer, Users, Zap, Rocket, Bomb, Sun, Moon, CheckCircle2, Circle, Crown } from 'lucide-react';

interface GameArenaProps {
    room: Room;
    nightMode: boolean;
    setNightMode: (val: boolean) => void;
    onLeave: () => void;
}

/* ‚îÄ‚îÄ Visual effect types ‚îÄ‚îÄ */
interface VFX {
    id: number;
    type: 'bomb' | 'rocket' | 'speed' | 'collect' | 'stun_stars' | 'speed_trail';
    x: number;
    y: number;
    timer: number;
    maxTimer: number;
    data?: any;
}

interface RocketProjectile {
    id: number;
    x: number;
    y: number;
    dx: number;
    dy: number;
    timer: number;
    trail: { x: number; y: number; alpha: number }[];
}

interface FloatingText {
    id: number;
    x: number;
    y: number;
    text: string;
    color: string;
    timer: number;
}

interface SpeedParticle {
    id: number;
    x: number;
    y: number;
    vx: number;
    vy: number;
    timer: number;
    maxTimer: number;
    color: string;
}

/* ‚îÄ‚îÄ Player colors ‚îÄ‚îÄ */
const PLAYER_COLORS = [
    '#ef4444', '#3b82f6', '#22c55e', '#eab308',
    '#a855f7', '#f97316', '#ec4899', '#06b6d4',
];

const TILE_SIZE = 64;
const GRID_COLS = 12;
const GRID_ROWS = 8;
const ARENA_W = GRID_COLS * TILE_SIZE; // 768
const ARENA_H = GRID_ROWS * TILE_SIZE; // 512
const TOTAL_GRASS = GRID_COLS * GRID_ROWS;
const MAX_PLAYERS = 8;

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   SPIKY GRASS BUSH ‚Äî pointed leaves radiating from center
   Matches reference: bright green star-burst on dark ground
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function makeDahliaTile(size: number): HTMLCanvasElement {
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const g = c.getContext('2d')!;
    const cx = size / 2, cy = size / 2;

    // ‚îÄ‚îÄ Dark ground base ‚îÄ‚îÄ
    g.fillStyle = '#4a3f5a';
    g.fillRect(0, 0, size, size);
    // Subtle ground texture
    g.fillStyle = '#544868';
    g.fillRect(0, 0, size / 2, size / 2);
    g.fillRect(size / 2, size / 2, size / 2, size / 2);
    // Tiny specks
    for (let i = 0; i < 6; i++) {
        g.fillStyle = 'rgba(0,0,0,0.15)';
        g.beginPath();
        g.arc(
            size * 0.15 + Math.cos(i * 1.7) * size * 0.3,
            size * 0.15 + Math.sin(i * 2.3) * size * 0.3,
            1.5, 0, Math.PI * 2
        );
        g.fill();
    }

    // ‚îÄ‚îÄ Center body (small dark green circle) ‚îÄ‚îÄ
    const bodyR = size * 0.12;
    g.fillStyle = '#2d6b2d';
    g.beginPath();
    g.arc(cx, cy, bodyR, 0, Math.PI * 2);
    g.fill();

    // ‚îÄ‚îÄ Spiky leaf blades ‚Äî two rings ‚îÄ‚îÄ
    // Outer ring: longer, thinner leaves
    const outerLeaves = 12;
    for (let i = 0; i < outerLeaves; i++) {
        const angle = (Math.PI * 2 / outerLeaves) * i + 0.15;
        const len = size * 0.38 + (i % 3) * size * 0.04;
        const tipX = cx + Math.cos(angle) * len;
        const tipY = cy + Math.sin(angle) * len;
        const halfW = size * 0.04;

        // Leaf shape: narrow at base, tapers to sharp point
        const baseX = cx + Math.cos(angle) * bodyR * 0.5;
        const baseY = cy + Math.sin(angle) * bodyR * 0.5;
        const perp = angle + Math.PI / 2;
        const midR = len * 0.4;
        const midX = cx + Math.cos(angle) * midR;
        const midY = cy + Math.sin(angle) * midR;

        // Alternate bright greens
        const colors = ['#5fcc37', '#4bb82a', '#6ed845', '#3da821', '#7ae650', '#51c02d'];
        g.fillStyle = colors[i % colors.length];

        g.beginPath();
        g.moveTo(tipX, tipY); // sharp tip
        g.quadraticCurveTo(
            midX + Math.cos(perp) * halfW * 1.8,
            midY + Math.sin(perp) * halfW * 1.8,
            baseX + Math.cos(perp) * halfW * 0.6,
            baseY + Math.sin(perp) * halfW * 0.6
        );
        g.lineTo(
            baseX - Math.cos(perp) * halfW * 0.6,
            baseY - Math.sin(perp) * halfW * 0.6
        );
        g.quadraticCurveTo(
            midX - Math.cos(perp) * halfW * 1.8,
            midY - Math.sin(perp) * halfW * 1.8,
            tipX, tipY
        );
        g.fill();

        // Light edge highlight
        g.strokeStyle = 'rgba(180,255,120,0.3)';
        g.lineWidth = 0.6;
        g.beginPath();
        g.moveTo(baseX, baseY);
        g.lineTo(tipX, tipY);
        g.stroke();
    }

    // Inner ring: shorter leaves, offset angle
    const innerLeaves = 10;
    for (let i = 0; i < innerLeaves; i++) {
        const angle = (Math.PI * 2 / innerLeaves) * i + 0.45;
        const len = size * 0.24 + (i % 2) * size * 0.03;
        const tipX = cx + Math.cos(angle) * len;
        const tipY = cy + Math.sin(angle) * len;
        const halfW = size * 0.035;

        const baseX = cx + Math.cos(angle) * bodyR * 0.3;
        const baseY = cy + Math.sin(angle) * bodyR * 0.3;
        const perp = angle + Math.PI / 2;
        const midR = len * 0.45;
        const midX = cx + Math.cos(angle) * midR;
        const midY = cy + Math.sin(angle) * midR;

        const cols = ['#7ae650', '#8bf065', '#6ed845', '#5fcc37'];
        g.fillStyle = cols[i % cols.length];

        g.beginPath();
        g.moveTo(tipX, tipY);
        g.quadraticCurveTo(
            midX + Math.cos(perp) * halfW * 1.6,
            midY + Math.sin(perp) * halfW * 1.6,
            baseX, baseY
        );
        g.quadraticCurveTo(
            midX - Math.cos(perp) * halfW * 1.6,
            midY - Math.sin(perp) * halfW * 1.6,
            tipX, tipY
        );
        g.fill();
    }

    // ‚îÄ‚îÄ Bright center highlight dot ‚îÄ‚îÄ
    g.fillStyle = '#a4f57a';
    g.beginPath();
    g.arc(cx, cy, size * 0.04, 0, Math.PI * 2);
    g.fill();

    return c;
}

/* ‚îÄ‚îÄ Dirt tile for eaten grass (dark ground matching theme) ‚îÄ‚îÄ */
function makeDirtTile(size: number): HTMLCanvasElement {
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const g = c.getContext('2d')!;
    const h = size / 2;

    // Dark purple ground
    g.fillStyle = '#4a3f5a';
    g.fillRect(0, 0, size, size);
    g.fillStyle = '#544868';
    g.fillRect(0, 0, h, h);
    g.fillRect(h, h, h, h);

    // Subtle pebble dots
    const pebbles = [[size * 0.2, size * 0.3], [size * 0.6, size * 0.15], [size * 0.75, size * 0.65], [size * 0.35, size * 0.7]];
    pebbles.forEach(([px, py]) => {
        g.fillStyle = 'rgba(0,0,0,0.2)';
        g.beginPath(); g.arc(px, py, 2.5, 0, Math.PI * 2); g.fill();
        g.fillStyle = 'rgba(255,255,255,0.06)';
        g.beginPath(); g.arc(px - 1, py - 1, 1.5, 0, Math.PI * 2); g.fill();
    });

    return c;
}

/* ‚îÄ‚îÄ Small Grass Tile (phase 2 ‚Äî miniature spiky bush on dark ground) ‚îÄ‚îÄ */
function makeSmallGrassTile(size: number): HTMLCanvasElement {
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const g = c.getContext('2d')!;
    const cx = size / 2, cy = size / 2;

    // Dark ground base
    const h = size / 2;
    g.fillStyle = '#4a3f5a';
    g.fillRect(0, 0, size, size);
    g.fillStyle = '#544868';
    g.fillRect(0, 0, h, h);
    g.fillRect(h, h, h, h);

    // Pebble dots
    for (let i = 0; i < 4; i++) {
        g.fillStyle = 'rgba(0,0,0,0.15)';
        g.beginPath();
        g.arc(size * 0.15 + Math.cos(i * 2.1) * size * 0.28,
              size * 0.2 + Math.sin(i * 2.7) * size * 0.25, 1.5, 0, Math.PI * 2);
        g.fill();
    }

    // Small center body
    const bodyR = size * 0.06;
    g.fillStyle = '#2d6b2d';
    g.beginPath();
    g.arc(cx, cy, bodyR, 0, Math.PI * 2);
    g.fill();

    // Spiky leaves ‚Äî 8 short pointy blades
    const leafCount = 8;
    for (let i = 0; i < leafCount; i++) {
        const angle = (Math.PI * 2 / leafCount) * i + 0.2;
        const len = size * 0.18 + (i % 3) * size * 0.02;
        const tipX = cx + Math.cos(angle) * len;
        const tipY = cy + Math.sin(angle) * len;
        const halfW = size * 0.02;

        const baseX = cx + Math.cos(angle) * bodyR * 0.4;
        const baseY = cy + Math.sin(angle) * bodyR * 0.4;
        const perp = angle + Math.PI / 2;
        const midR = len * 0.4;
        const midX = cx + Math.cos(angle) * midR;
        const midY = cy + Math.sin(angle) * midR;

        const colors = ['#7ae650', '#6ed845', '#5fcc37', '#8bf065'];
        g.fillStyle = colors[i % colors.length];

        g.beginPath();
        g.moveTo(tipX, tipY);
        g.quadraticCurveTo(
            midX + Math.cos(perp) * halfW * 1.5,
            midY + Math.sin(perp) * halfW * 1.5,
            baseX, baseY
        );
        g.quadraticCurveTo(
            midX - Math.cos(perp) * halfW * 1.5,
            midY - Math.sin(perp) * halfW * 1.5,
            tipX, tipY
        );
        g.fill();
    }

    // Bright center dot
    g.fillStyle = '#a4f57a';
    g.beginPath(); g.arc(cx, cy, size * 0.025, 0, Math.PI * 2); g.fill();

    return c;
}

/* ‚îÄ‚îÄ Power-up icon drawing (canvas-drawn shapes) ‚îÄ‚îÄ */
function drawPowerUpIcon(ctx: CanvasRenderingContext2D, x: number, y: number, type: string, time: number) {
    const bounce = Math.sin(time * 4) * 3;
    const glow = 0.5 + 0.3 * Math.sin(time * 6);

    ctx.save();
    ctx.translate(x, y + bounce);

    if (type === 'bomb') {
        // Bomb: dark circle with fuse and spark
        // Glow
        ctx.fillStyle = `rgba(239,68,68,${glow * 0.4})`;
        ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.fill();

        // Body (dark sphere)
        ctx.fillStyle = '#2a2020';
        ctx.beginPath(); ctx.arc(0, 2, 11, 0, Math.PI * 2); ctx.fill();

        // Highlight crescent
        ctx.fillStyle = '#4a3838';
        ctx.beginPath(); ctx.arc(-3, -1, 8, 0, Math.PI * 2); ctx.fill();

        // Top fuse cap
        ctx.fillStyle = '#888';
        ctx.fillRect(-3, -11, 6, 5);

        // Fuse string
        ctx.strokeStyle = '#d4a017';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, -11);
        ctx.quadraticCurveTo(5, -16, 3, -19);
        ctx.stroke();

        // Spark at fuse tip
        const sparkFlicker = 0.6 + 0.4 * Math.sin(time * 12);
        ctx.fillStyle = `rgba(255,200,50,${sparkFlicker})`;
        ctx.beginPath(); ctx.arc(3, -19, 3, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = `rgba(255,100,30,${sparkFlicker * 0.7})`;
        ctx.beginPath(); ctx.arc(3, -19, 5, 0, Math.PI * 2); ctx.fill();

    } else if (type === 'rocket') {
        // Rocket: red/orange body, yellow nose, fins
        // Background glow box
        ctx.fillStyle = `rgba(249,165,22,${glow * 0.3})`;
        ctx.fillRect(-14, -14, 28, 28);

        // Body
        ctx.fillStyle = '#ff5533';
        ctx.fillRect(-4, -8, 8, 16);

        // Nose cone
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(-4, -8);
        ctx.lineTo(0, -15);
        ctx.lineTo(4, -8);
        ctx.closePath();
        ctx.fill();

        // Fins
        ctx.fillStyle = '#cc3300';
        ctx.beginPath();
        ctx.moveTo(-4, 5); ctx.lineTo(-8, 10); ctx.lineTo(-4, 8); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(4, 5); ctx.lineTo(8, 10); ctx.lineTo(4, 8); ctx.fill();

        // Exhaust flame
        const flameH = 4 + Math.random() * 3;
        ctx.fillStyle = '#ffa500';
        ctx.beginPath();
        ctx.moveTo(-3, 8); ctx.lineTo(0, 8 + flameH); ctx.lineTo(3, 8);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.moveTo(-1.5, 8); ctx.lineTo(0, 8 + flameH * 0.6); ctx.lineTo(1.5, 8);
        ctx.closePath(); ctx.fill();

        // Window
        ctx.fillStyle = '#87ceeb';
        ctx.beginPath(); ctx.arc(0, -2, 2.5, 0, Math.PI * 2); ctx.fill();

    } else if (type === 'speed') {
        // Speed boot: blue sneaker shape
        // Background glow
        ctx.fillStyle = `rgba(56,189,248,${glow * 0.3})`;
        ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI * 2); ctx.fill();

        // Boot sole
        ctx.fillStyle = '#1e3a5f';
        ctx.beginPath();
        ctx.moveTo(-10, 6); ctx.lineTo(10, 6);
        ctx.lineTo(12, 9); ctx.lineTo(-10, 9);
        ctx.closePath(); ctx.fill();

        // Boot body
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.moveTo(-6, 6); ctx.lineTo(-8, -4);
        ctx.lineTo(-4, -8); ctx.lineTo(0, -6);
        ctx.lineTo(6, 0); ctx.lineTo(10, 6);
        ctx.closePath(); ctx.fill();

        // Tongue
        ctx.fillStyle = '#60a5fa';
        ctx.beginPath();
        ctx.moveTo(-4, -8); ctx.lineTo(-2, -11); ctx.lineTo(1, -7);
        ctx.closePath(); ctx.fill();

        // Speed lines
        ctx.strokeStyle = '#93c5fd';
        ctx.lineWidth = 1.2;
        for (let i = 0; i < 3; i++) {
            const ly = -4 + i * 5;
            ctx.beginPath();
            ctx.moveTo(-14 - i * 2, ly);
            ctx.lineTo(-10, ly);
            ctx.stroke();
        }
    }

    ctx.restore();
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   TOP-DOWN WALKING CHARACTER
   Renders a character from above with animated legs
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function drawTopDownCharacter(
    ctx: CanvasRenderingContext2D,
    player: any,
    color: string,
    isLocal: boolean,
    time: number
) {
    const px = player.x;
    const py = player.y;
    const isMoving = Math.abs(player.velocityX) > 5 || Math.abs(player.velocityY) > 5;
    const isStunned = player.stunTimer > 0;
    const isSpeed = player.speedMultiplier > 1;

    ctx.save();
    ctx.translate(px, py);

    // ‚îÄ‚îÄ Speed boost aura ‚îÄ‚îÄ
    if (isSpeed) {
        const auraAlpha = 0.3 + 0.2 * Math.sin(time * 8);
        const auraGrad = ctx.createRadialGradient(0, 0, 6, 0, 0, 40);
        auraGrad.addColorStop(0, `rgba(251,191,36,${auraAlpha})`);
        auraGrad.addColorStop(1, 'rgba(251,191,36,0)');
        ctx.fillStyle = auraGrad;
        ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.fill();
    }

    // ‚îÄ‚îÄ Stun effect: spinning stars ‚îÄ‚îÄ
    if (isStunned) {
        const starCount = 3;
        for (let i = 0; i < starCount; i++) {
            const angle = (Math.PI * 2 / starCount) * i + time * 4;
            const starX = Math.cos(angle) * 30;
            const starY = Math.sin(angle) * 14 - 34;
            ctx.save();
            ctx.translate(starX, starY);
            ctx.rotate(time * 6 + i);
            drawStar5(ctx, 0, 0, 6, 3, '#fbbf24');
            ctx.restore();
        }

        // Dazed overlay on character
        ctx.globalAlpha = 0.3 + 0.2 * Math.sin(time * 10);
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
    }

    // ‚îÄ‚îÄ Movement direction ‚îÄ‚îÄ
    let facing = 0; // radians
    if (isMoving) {
        facing = Math.atan2(player.velocityY, player.velocityX);
    }

    // ‚îÄ‚îÄ Walking leg animation ‚îÄ‚îÄ
    const walkCycle = isMoving ? Math.sin(time * 10) * 0.5 : 0;
    const bodyR = 20; // bigger body radius

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(3, 5, bodyR + 3, bodyR - 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // ‚îÄ‚îÄ LEGS (drawn behind body) ‚îÄ‚îÄ
    const legOffset = bodyR * 0.8;
    const legSpread = 9;
    const legW = 9, legH = 13;

    ctx.save();
    ctx.rotate(facing + Math.PI / 2); // Rotate so legs trail behind movement

    // Leg 1 (left side)
    ctx.save();
    ctx.translate(-legSpread, legOffset + walkCycle * 5);
    ctx.rotate(walkCycle * 0.3);
    drawLeg(ctx, color, legW, legH, isStunned);
    ctx.restore();

    // Leg 2 (right side)
    ctx.save();
    ctx.translate(legSpread, legOffset - walkCycle * 5);
    ctx.rotate(-walkCycle * 0.3);
    drawLeg(ctx, color, legW, legH, isStunned);
    ctx.restore();

    ctx.restore(); // facing rotation

    // ‚îÄ‚îÄ BODY (top-down oval) ‚îÄ‚îÄ
    ctx.save();
    ctx.rotate(isStunned ? Math.sin(time * 15) * 0.2 : 0); // wobble when stunned

    // Body gradient
    const bodyGrad = ctx.createRadialGradient(-4, -4, 2, 0, 0, bodyR);
    bodyGrad.addColorStop(0, lightenColor(color, 40));
    bodyGrad.addColorStop(0.6, color);
    bodyGrad.addColorStop(1, darkenColor(color, 30));
    ctx.fillStyle = bodyGrad;
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.ellipse(0, 0, bodyR, bodyR - 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Belt stripe across middle
    ctx.save();
    ctx.clip();
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-bodyR, -2, bodyR * 2, 4);
    // Belt buckle
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(-3, -2, 6, 4);
    ctx.restore();

    ctx.restore(); // wobble rotation

    const headR = 13;
    const headX = Math.cos(facing) * 7;
    const headY = Math.sin(facing) * 7;

    // Head shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.arc(headX + 2, headY + 2, headR, 0, Math.PI * 2); ctx.fill();

    // Head
    const headGrad = ctx.createRadialGradient(headX - 2, headY - 2, 1, headX, headY, headR);
    headGrad.addColorStop(0, lightenColor(color, 50));
    headGrad.addColorStop(1, color);
    ctx.fillStyle = headGrad;
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(headX, headY, headR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

    // Eyes ‚Äî 2 small dots oriented toward movement direction
    const eyeAngle1 = facing - 0.4;
    const eyeAngle2 = facing + 0.4;
    const eyeDist = headR * 0.5;
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(headX + Math.cos(eyeAngle1) * eyeDist, headY + Math.sin(eyeAngle1) * eyeDist, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(headX + Math.cos(eyeAngle2) * eyeDist, headY + Math.sin(eyeAngle2) * eyeDist, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(headX + Math.cos(eyeAngle1) * eyeDist + 0.5, headY + Math.sin(eyeAngle1) * eyeDist + 0.5, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(headX + Math.cos(eyeAngle2) * eyeDist + 0.5, headY + Math.sin(eyeAngle2) * eyeDist + 0.5, 2, 0, Math.PI * 2); ctx.fill();

    // ‚îÄ‚îÄ Arms ‚îÄ‚îÄ small stumps on sides
    ctx.save();
    ctx.rotate(facing + Math.PI / 2);
    const armSpread = bodyR + 2;
    // Left arm
    ctx.fillStyle = color;
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 1.5;
    ctx.save();
    ctx.translate(-armSpread, -4);
    ctx.rotate(isMoving ? -walkCycle * 0.5 : 0);
    ctx.beginPath(); ctx.ellipse(0, 0, 5, 8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    ctx.restore();
    // Right arm
    ctx.save();
    ctx.translate(armSpread, -4);
    ctx.rotate(isMoving ? walkCycle * 0.5 : 0);
    ctx.beginPath(); ctx.ellipse(0, 0, 5, 8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    ctx.restore();
    ctx.restore();

    // ‚îÄ‚îÄ Local player indicator ‚îÄ‚îÄ
    if (isLocal) {
        const pulse = (Math.sin(time * 4) + 1) / 2;
        ctx.strokeStyle = '#fbbf24';
        ctx.setLineDash([5, 4]);
        ctx.lineWidth = 2;
        const pad = 26 + pulse * 4;
        ctx.beginPath(); ctx.arc(0, 0, pad, 0, Math.PI * 2); ctx.stroke();
        ctx.setLineDash([]);
    }

    // ‚îÄ‚îÄ Speed boost lightning bolts ‚îÄ‚îÄ
    if (isSpeed) {
        for (let i = 0; i < 3; i++) {
            const boltAngle = (Math.PI * 2 / 3) * i + time * 5;
            const bx = Math.cos(boltAngle) * 22;
            const by = Math.sin(boltAngle) * 22;
            ctx.save();
            ctx.translate(bx, by);
            ctx.rotate(boltAngle);
            ctx.fillStyle = '#fbbf24';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚ö°', 0, 0);
            ctx.restore();
        }
    }

    ctx.restore(); // main translate

    // ‚îÄ‚îÄ Name label ‚îÄ‚îÄ
    ctx.save();
    ctx.translate(px, py);
    ctx.font = 'bold 8px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.strokeText(player.displayName, 0, -30);
    ctx.fillStyle = isLocal ? '#fbbf24' : '#fff';
    ctx.fillText(player.displayName, 0, -30);

    // Score below
    ctx.font = 'bold 7px "Press Start 2P", monospace';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.strokeText(`${player.score}`, 0, 36);
    ctx.fillStyle = '#4ade80';
    ctx.fillText(`${player.score}`, 0, 36);
    ctx.restore();
}

function drawLeg(ctx: CanvasRenderingContext2D, color: string, w: number, h: number, stunned: boolean) {
    // Boot (bottom dark part)
    ctx.fillStyle = '#1c1917';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.ellipse(0, h / 4, w * 0.65, h * 0.35, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    // Leg skin
    ctx.fillStyle = stunned ? '#fbbf24' : color;
    ctx.beginPath(); ctx.ellipse(0, -h / 4, w * 0.5, h * 0.45, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
}

function drawStar5(ctx: CanvasRenderingContext2D, cx: number, cy: number, outerR: number, innerR: number, color: string) {
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
        const angle = (Math.PI / 5) * i - Math.PI / 2;
        const r = i % 2 === 0 ? outerR : innerR;
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath(); ctx.fill();
}

function lightenColor(hex: string, amount: number): string {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgb(${Math.min(255, r + amount)},${Math.min(255, g + amount)},${Math.min(255, b + amount)})`;
}

function darkenColor(hex: string, amount: number): string {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgb(${Math.max(0, r - amount)},${Math.max(0, g - amount)},${Math.max(0, b - amount)})`;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PIXEL-ART FOREST BACKGROUND
   Layered forest scene with animated trees, walking characters,
   ground details, and atmospheric particles
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

/* ‚îÄ‚îÄ Helper: draw a pixel-art pine tree ‚îÄ‚îÄ */
function drawPineTree(
    ctx: CanvasRenderingContext2D,
    x: number, baseY: number,
    h: number, w: number,
    trunkW: number, trunkH: number,
    colors: string[], trunkColor: string,
    sway: number
) {
    ctx.save();
    ctx.translate(x, baseY);
    // Trunk
    ctx.fillStyle = trunkColor;
    ctx.fillRect(-trunkW / 2, -trunkH, trunkW, trunkH);
    // Trunk highlight
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(-trunkW / 2, -trunkH, trunkW / 3, trunkH);

    // Layered triangular canopy with sway
    const layers = 4;
    for (let i = 0; i < layers; i++) {
        const layerH = h / layers;
        const layerW = w * (1 - i * 0.2);
        const yOff = -trunkH - i * layerH * 0.75;
        const xSway = sway * (i + 1) * 0.3;

        ctx.fillStyle = colors[i % colors.length];
        ctx.beginPath();
        ctx.moveTo(xSway, yOff - layerH);
        ctx.lineTo(-layerW / 2 + xSway * 0.5, yOff);
        ctx.lineTo(layerW / 2 + xSway * 0.5, yOff);
        ctx.closePath();
        ctx.fill();

        // Edge highlight
        ctx.fillStyle = colors[(i + 1) % colors.length];
        ctx.beginPath();
        ctx.moveTo(xSway, yOff - layerH);
        ctx.lineTo(-layerW / 4 + xSway * 0.6, yOff - layerH * 0.2);
        ctx.lineTo(-layerW / 2.5 + xSway * 0.5, yOff);
        ctx.closePath();
        ctx.fill();
    }
    ctx.restore();
}

/* ‚îÄ‚îÄ Helper: draw a tall deciduous tree ‚îÄ‚îÄ */
function drawTallTree(
    ctx: CanvasRenderingContext2D,
    x: number, baseY: number,
    trunkH: number, canopyR: number,
    colors: string[], trunkColor: string,
    sway: number
) {
    ctx.save();
    ctx.translate(x, baseY);
    const tw = 8 + canopyR * 0.15;

    // Trunk
    ctx.fillStyle = trunkColor;
    ctx.fillRect(-tw / 2, -trunkH, tw, trunkH);
    // Bark texture lines
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    for (let i = 0; i < trunkH; i += 12) {
        ctx.beginPath();
        ctx.moveTo(-tw / 2 + 2, -i);
        ctx.lineTo(-tw / 2 + tw - 2, -i - 4);
        ctx.stroke();
    }
    // Trunk highlight
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(-tw / 2, -trunkH, tw / 3, trunkH);

    // Canopy ‚Äî overlapping round clusters
    const cx = sway * 2;
    const cy = -trunkH;
    const clusters = [
        { dx: 0, dy: -canopyR * 0.4, r: canopyR },
        { dx: -canopyR * 0.6, dy: -canopyR * 0.1, r: canopyR * 0.75 },
        { dx: canopyR * 0.55, dy: -canopyR * 0.15, r: canopyR * 0.7 },
        { dx: -canopyR * 0.3, dy: -canopyR * 0.8, r: canopyR * 0.6 },
        { dx: canopyR * 0.25, dy: -canopyR * 0.75, r: canopyR * 0.55 },
    ];
    clusters.forEach((cl, i) => {
        ctx.fillStyle = colors[i % colors.length];
        ctx.beginPath();
        ctx.arc(cx + cl.dx, cy + cl.dy, cl.r, 0, Math.PI * 2);
        ctx.fill();
    });

    // Highlight spots
    ctx.fillStyle = 'rgba(180,255,100,0.12)';
    ctx.beginPath();
    ctx.arc(cx - canopyR * 0.3, cy - canopyR * 0.6, canopyR * 0.25, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
}

/* ‚îÄ‚îÄ Helper: draw grass tufts ‚îÄ‚îÄ */
function drawGrassTuft(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, color: string, sway: number) {
    const blades = 5 + Math.floor(w / 4);
    for (let i = 0; i < blades; i++) {
        const bx = x - w / 2 + (w / blades) * i + Math.sin(i * 1.3) * 2;
        const bh = h * (0.6 + Math.sin(i * 2.1) * 0.4);
        const tipSway = sway * (0.5 + i * 0.1);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(bx - 1.5, y);
        ctx.quadraticCurveTo(bx + tipSway, y - bh, bx + tipSway + 1, y - bh + 2);
        ctx.quadraticCurveTo(bx + tipSway + 2, y - bh / 2, bx + 1.5, y);
        ctx.closePath();
        ctx.fill();
    }
}

/* ‚îÄ‚îÄ Helper: draw a small walking pixel character ‚îÄ‚îÄ */
function drawWalkingChar(ctx: CanvasRenderingContext2D, x: number, y: number, size: number, color: string, time: number, speed: number) {
    const walk = Math.sin(time * speed) * 2;
    const legSwing = Math.sin(time * speed * 2) * 3;
    ctx.save();
    ctx.translate(x, y);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(-size * 0.6, size * 0.1, size * 1.2, size * 0.2);

    // Legs
    ctx.fillStyle = darkenColor(color, 40);
    ctx.fillRect(-size * 0.25 + legSwing * 0.3, -size * 0.1, size * 0.2, size * 0.35);
    ctx.fillRect(size * 0.1 - legSwing * 0.3, -size * 0.1, size * 0.2, size * 0.35);

    // Body
    ctx.fillStyle = color;
    ctx.fillRect(-size * 0.3, -size * 0.7 + walk * 0.3, size * 0.6, size * 0.65);

    // Head
    ctx.fillStyle = lightenColor(color, 20);
    ctx.fillRect(-size * 0.25, -size + walk * 0.3, size * 0.5, size * 0.35);

    // Eyes
    ctx.fillStyle = '#fff';
    ctx.fillRect(size * 0.0, -size * 0.85 + walk * 0.3, size * 0.12, size * 0.1);
    ctx.fillRect(size * 0.15, -size * 0.85 + walk * 0.3, size * 0.12, size * 0.1);

    ctx.restore();
}

/* ‚îÄ‚îÄ Helper: draw pixel rock ‚îÄ‚îÄ */
function drawRock(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, nightMode: boolean) {
    const baseColor = nightMode ? '#4a4e69' : '#8d99ae';
    const highlightColor = nightMode ? '#6c7086' : '#b8c0cc';
    const shadowColor = nightMode ? '#2b2d42' : '#6b7280';

    ctx.fillStyle = shadowColor;
    ctx.beginPath();
    ctx.moveTo(x - w * 0.5, y);
    ctx.lineTo(x - w * 0.3, y - h);
    ctx.lineTo(x + w * 0.4, y - h * 0.85);
    ctx.lineTo(x + w * 0.55, y);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.moveTo(x - w * 0.45, y);
    ctx.lineTo(x - w * 0.2, y - h * 0.95);
    ctx.lineTo(x + w * 0.35, y - h * 0.8);
    ctx.lineTo(x + w * 0.5, y);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = highlightColor;
    ctx.beginPath();
    ctx.moveTo(x - w * 0.15, y - h * 0.9);
    ctx.lineTo(x + w * 0.05, y - h * 0.6);
    ctx.lineTo(x - w * 0.3, y - h * 0.4);
    ctx.closePath();
    ctx.fill();
}

function drawArenaBackground(
    ctx: CanvasRenderingContext2D,
    W: number, H: number,
    offsetX: number, offsetY: number,
    nightMode: boolean,
    time: number
) {
    // ‚ïê‚ïê‚ïê SKY GRADIENT ‚ïê‚ïê‚ïê
    const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
    if (nightMode) {
        skyGrad.addColorStop(0, '#0a0e1a');
        skyGrad.addColorStop(0.3, '#111833');
        skyGrad.addColorStop(0.6, '#1a2040');
        skyGrad.addColorStop(1, '#0d1117');
    } else {
        skyGrad.addColorStop(0, '#87ceeb');
        skyGrad.addColorStop(0.25, '#a8d8ea');
        skyGrad.addColorStop(0.5, '#c5ddd6');
        skyGrad.addColorStop(0.75, '#7ba68a');
        skyGrad.addColorStop(1, '#3a5a40');
    }
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, H);

    // ‚ïê‚ïê‚ïê SUN (day mode) ‚ïê‚ïê‚ïê
    if (!nightMode) {
        const sunX = W * 0.18, sunY = H * 0.13;
        // Outer glow
        const sunGlow = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, 80);
        sunGlow.addColorStop(0, 'rgba(255,250,200,0.5)');
        sunGlow.addColorStop(0.4, 'rgba(255,220,100,0.2)');
        sunGlow.addColorStop(1, 'rgba(255,200,50,0)');
        ctx.fillStyle = sunGlow;
        ctx.beginPath(); ctx.arc(sunX, sunY, 80, 0, Math.PI * 2); ctx.fill();

        // Sun body
        ctx.fillStyle = '#ffe066';
        ctx.beginPath(); ctx.arc(sunX, sunY, 28, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff8d6';
        ctx.beginPath(); ctx.arc(sunX - 5, sunY - 5, 18, 0, Math.PI * 2); ctx.fill();

        // Animated sun rays
        const rayCount = 12;
        for (let r = 0; r < rayCount; r++) {
            const rayAngle = (Math.PI * 2 / rayCount) * r + time * 0.3;
            const rayLen = 18 + Math.sin(time * 2 + r * 1.5) * 8;
            const rayStart = 32;
            const rx1 = sunX + Math.cos(rayAngle) * rayStart;
            const ry1 = sunY + Math.sin(rayAngle) * rayStart;
            const rx2 = sunX + Math.cos(rayAngle) * (rayStart + rayLen);
            const ry2 = sunY + Math.sin(rayAngle) * (rayStart + rayLen);
            ctx.strokeStyle = `rgba(255,230,100,${0.4 + Math.sin(time * 3 + r) * 0.2})`;
            ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.moveTo(rx1, ry1); ctx.lineTo(rx2, ry2); ctx.stroke();
        }
    }

    // ‚ïê‚ïê‚ïê STARS (night only) ‚ïê‚ïê‚ïê
    if (nightMode) {
        const starSeed = [0.1, 0.23, 0.45, 0.67, 0.82, 0.91, 0.34, 0.56, 0.78, 0.12,
                          0.38, 0.61, 0.85, 0.07, 0.49, 0.72, 0.28, 0.53, 0.94, 0.16];
        for (let i = 0; i < starSeed.length; i++) {
            const sx = starSeed[i] * W;
            const sy = starSeed[(i + 7) % starSeed.length] * H * 0.45;
            const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(time * 1.5 + i * 1.7));
            ctx.fillStyle = `rgba(255,255,240,${twinkle * 0.6})`;
            ctx.fillRect(sx, sy, 2, 2);
        }
        // Moon
        ctx.fillStyle = 'rgba(220,230,255,0.15)';
        ctx.beginPath(); ctx.arc(W * 0.82, H * 0.12, 50, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'rgba(220,230,255,0.3)';
        ctx.beginPath(); ctx.arc(W * 0.82, H * 0.12, 30, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'rgba(240,245,255,0.6)';
        ctx.beginPath(); ctx.arc(W * 0.82, H * 0.12, 18, 0, Math.PI * 2); ctx.fill();
    }

    // ‚ïê‚ïê‚ïê PIXEL CLOUDS ‚ïê‚ïê‚ïê
    const cloudDefs = [
        { baseX: W * 0.1, y: H * 0.08, w: 90, h: 30, speed: 0.015 },
        { baseX: W * 0.35, y: H * 0.14, w: 120, h: 35, speed: 0.01 },
        { baseX: W * 0.62, y: H * 0.06, w: 80, h: 25, speed: 0.018 },
        { baseX: W * 0.85, y: H * 0.18, w: 100, h: 32, speed: 0.012 },
        { baseX: W * 0.5, y: H * 0.22, w: 70, h: 22, speed: 0.02 },
    ];
    cloudDefs.forEach(cl => {
        // Drift clouds across the screen (loop around)
        const cx = ((cl.baseX + time * cl.speed * W) % (W + cl.w * 2)) - cl.w;
        const cloudAlpha = nightMode ? 0.08 : 0.65;
        const cloudColor = nightMode ? `rgba(60,70,100,${cloudAlpha})` : `rgba(255,255,255,${cloudAlpha})`;
        const cloudShadow = nightMode ? `rgba(30,40,60,${cloudAlpha * 0.5})` : `rgba(200,210,220,${cloudAlpha * 0.6})`;

        ctx.fillStyle = cloudShadow;
        // Shadow blobs slightly offset
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.3, cl.y + cl.h * 0.6, cl.h * 0.55, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.6, cl.y + cl.h * 0.55, cl.h * 0.5, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = cloudColor;
        // Main cloud body ‚Äî pixel-ish rounded blobs
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.2, cl.y, cl.h * 0.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.45, cl.y - cl.h * 0.2, cl.h * 0.65, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.7, cl.y, cl.h * 0.55, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.35, cl.y + cl.h * 0.1, cl.h * 0.45, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.55, cl.y + cl.h * 0.05, cl.h * 0.5, 0, Math.PI * 2); ctx.fill();

        // Bright highlight on top
        const hlColor = nightMode ? `rgba(80,90,120,${cloudAlpha * 0.4})` : `rgba(255,255,255,${cloudAlpha * 0.5})`;
        ctx.fillStyle = hlColor;
        ctx.beginPath(); ctx.arc(cx + cl.w * 0.4, cl.y - cl.h * 0.3, cl.h * 0.3, 0, Math.PI * 2); ctx.fill();
    });

    // ‚ïê‚ïê‚ïê BIRDS (small V-shapes flying in sky) ‚ïê‚ïê‚ïê
    const birdCount = nightMode ? 3 : 6;
    for (let b = 0; b < birdCount; b++) {
        const bSeed = ((b * 71 + 23) % 100) / 100;
        const bx = ((bSeed * W + time * (20 + b * 8)) % (W + 60)) - 30;
        const by = H * 0.05 + bSeed * H * 0.18 + Math.sin(time * 2 + b * 1.5) * 8;
        const flapAngle = Math.sin(time * 6 + b * 2) * 0.4;
        const birdColor = nightMode ? 'rgba(150,160,200,0.4)' : 'rgba(40,40,50,0.6)';

        ctx.strokeStyle = birdColor;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(bx - 6, by + flapAngle * 5);
        ctx.lineTo(bx, by);
        ctx.lineTo(bx + 6, by + flapAngle * 5);
        ctx.stroke();
    }

    // ‚ïê‚ïê‚ïê SKY-AREA PIXEL CHARACTERS (doing activities) ‚ïê‚ïê‚ïê

    // --- Runner on far mountain ridge ---
    {
        const ridgeY = H * 0.3 + Math.sin(0.005 * ((120 + time * 30) % W) + 2) * (-40) + Math.sin(0.012 * ((120 + time * 30) % W) + 1) * (-25) + 40;
        const runnerX = ((120 + time * 30) % (W + 40)) - 20;
        const rSize = 6;
        const rTime = time;
        const rSpeed = 7;
        const rWalk = Math.sin(rTime * rSpeed) * 1.5;
        const rLeg = Math.sin(rTime * rSpeed * 2) * 2;
        const runColor = nightMode ? '#6a7aaa' : '#d97706';
        ctx.save(); ctx.translate(runnerX, ridgeY - 2);
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(-rSize * 0.5, rSize * 0.1, rSize, rSize * 0.15);
        ctx.fillStyle = darkenColor(runColor, 30);
        ctx.fillRect(-rSize * 0.2 + rLeg * 0.3, -rSize * 0.05, rSize * 0.15, rSize * 0.3);
        ctx.fillRect(rSize * 0.08 - rLeg * 0.3, -rSize * 0.05, rSize * 0.15, rSize * 0.3);
        ctx.fillStyle = runColor;
        ctx.fillRect(-rSize * 0.25, -rSize * 0.6 + rWalk * 0.2, rSize * 0.5, rSize * 0.55);
        ctx.fillStyle = lightenColor(runColor, 25);
        ctx.fillRect(-rSize * 0.2, -rSize * 0.85 + rWalk * 0.2, rSize * 0.4, rSize * 0.3);
        // Tiny flag the runner carries
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(rSize * 0.2, -rSize * 1.1 + rWalk * 0.2, 1, rSize * 0.45);
        ctx.fillRect(rSize * 0.2, -rSize * 1.1 + rWalk * 0.2, rSize * 0.25, rSize * 0.15);
        ctx.restore();
    }

    // --- Second mountain runner (opposite direction) ---
    {
        const ridgeY2 = H * 0.38 + Math.sin(0.005 * ((W - 80 - time * 20) % W) + 4) * (-40) + Math.sin(0.012 * ((W - 80 - time * 20) % W) + 2) * (-25) + 40;
        const runner2X = W - ((80 + time * 20) % (W + 40)) + 20;
        const rSize = 5;
        const rWalk = Math.sin(time * 6) * 1.2;
        const rLeg = Math.sin(time * 12) * 2;
        const runColor = nightMode ? '#7a8acc' : '#2563eb';
        ctx.save(); ctx.translate(runner2X, ridgeY2 - 2);
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fillRect(-rSize * 0.5, rSize * 0.1, rSize, rSize * 0.12);
        ctx.fillStyle = darkenColor(runColor, 30);
        ctx.fillRect(-rSize * 0.2 + rLeg * 0.25, -rSize * 0.05, rSize * 0.15, rSize * 0.28);
        ctx.fillRect(rSize * 0.08 - rLeg * 0.25, -rSize * 0.05, rSize * 0.15, rSize * 0.28);
        ctx.fillStyle = runColor;
        ctx.fillRect(-rSize * 0.22, -rSize * 0.55 + rWalk * 0.2, rSize * 0.45, rSize * 0.5);
        ctx.fillStyle = lightenColor(runColor, 20);
        ctx.fillRect(-rSize * 0.18, -rSize * 0.8 + rWalk * 0.2, rSize * 0.36, rSize * 0.28);
        ctx.restore();
    }

    // --- Lumberjack chopping near a tree stump (left side) ---
    {
        const lx = W * 0.04, ly = H * 0.55;
        const chop = Math.abs(Math.sin(time * 3));
        const axeAngle = -0.8 + chop * 1.2;
        const lSize = 9;
        const lColor = nightMode ? '#6b8065' : '#92400e';

        // Tree stump
        ctx.fillStyle = nightMode ? '#2a1f15' : '#6b4226';
        ctx.fillRect(lx + 14, ly - 10, 8, 10);
        ctx.fillStyle = nightMode ? '#3a2f22' : '#8b6240';
        ctx.fillRect(lx + 13, ly - 12, 10, 4);
        // Stump rings
        ctx.strokeStyle = nightMode ? '#1a1510' : '#5a3a1a';
        ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.arc(lx + 18, ly - 10, 3, 0, Math.PI * 2); ctx.stroke();

        // Lumberjack body
        ctx.save(); ctx.translate(lx, ly);
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(-lSize * 0.5, lSize * 0.05, lSize, lSize * 0.15);
        ctx.fillStyle = darkenColor(lColor, 30);
        ctx.fillRect(-lSize * 0.2, -lSize * 0.05, lSize * 0.18, lSize * 0.3);
        ctx.fillRect(lSize * 0.05, -lSize * 0.05, lSize * 0.18, lSize * 0.3);
        ctx.fillStyle = lColor;
        ctx.fillRect(-lSize * 0.28, -lSize * 0.6, lSize * 0.56, lSize * 0.58);
        ctx.fillStyle = lightenColor(lColor, 20);
        ctx.fillRect(-lSize * 0.22, -lSize * 0.88, lSize * 0.44, lSize * 0.32);
        // Axe
        ctx.save();
        ctx.translate(lSize * 0.25, -lSize * 0.45);
        ctx.rotate(axeAngle);
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, 2, lSize * 0.7);
        ctx.fillStyle = '#999';
        ctx.fillRect(-2, lSize * 0.55, 6, 4);
        ctx.restore();
        // Woodchips flying when chopping down
        if (chop > 0.8) {
            const chipColor = nightMode ? '#5a4530' : '#c4a35a';
            for (let c = 0; c < 3; c++) {
                const cx2 = 12 + Math.sin(time * 8 + c * 2) * 6;
                const cy2 = -8 - Math.abs(Math.sin(time * 10 + c * 3)) * 10;
                ctx.fillStyle = chipColor;
                ctx.fillRect(cx2, cy2, 2, 2);
            }
        }
        ctx.restore();
    }

    // --- Jumping/celebrating character (mid-sky, on a hill) ---
    {
        const jx = W * 0.92, jy = H * 0.42;
        const jumpH = Math.abs(Math.sin(time * 2.5)) * 15;
        const jSize = 7;
        const jColor = nightMode ? '#8888cc' : '#ec4899';
        const armWave = Math.sin(time * 5) * 0.6;

        ctx.save(); ctx.translate(jx, jy - jumpH);
        // Shadow on ground at base (stays put)
        ctx.fillStyle = `rgba(0,0,0,${0.1 + 0.05 * (1 - jumpH / 15)})`;
        ctx.fillRect(-jSize * 0.6, jumpH + jSize * 0.1, jSize * 1.2, jSize * 0.15);
        // Legs
        ctx.fillStyle = darkenColor(jColor, 35);
        ctx.fillRect(-jSize * 0.2, -jSize * 0.05, jSize * 0.15, jSize * 0.3);
        ctx.fillRect(jSize * 0.08, -jSize * 0.05, jSize * 0.15, jSize * 0.3);
        // Body
        ctx.fillStyle = jColor;
        ctx.fillRect(-jSize * 0.25, -jSize * 0.6, jSize * 0.5, jSize * 0.55);
        // Head
        ctx.fillStyle = lightenColor(jColor, 25);
        ctx.fillRect(-jSize * 0.2, -jSize * 0.88, jSize * 0.4, jSize * 0.3);
        // Eyes (happy squint)
        ctx.fillStyle = '#fff';
        ctx.fillRect(jSize * 0.0, -jSize * 0.78, jSize * 0.08, jSize * 0.06);
        ctx.fillRect(jSize * 0.12, -jSize * 0.78, jSize * 0.08, jSize * 0.06);
        // Arms raised & waving
        ctx.fillStyle = jColor;
        ctx.save(); ctx.translate(-jSize * 0.3, -jSize * 0.5); ctx.rotate(-1.2 + armWave);
        ctx.fillRect(0, 0, jSize * 0.12, jSize * 0.4);
        ctx.restore();
        ctx.save(); ctx.translate(jSize * 0.3, -jSize * 0.5); ctx.rotate(1.2 - armWave);
        ctx.fillRect(-jSize * 0.12, 0, jSize * 0.12, jSize * 0.4);
        ctx.restore();
        // Sparkle particles when at peak
        if (jumpH > 12) {
            const spkColor = nightMode ? '#aabbff' : '#fbbf24';
            for (let s = 0; s < 4; s++) {
                const sa = (Math.PI * 2 / 4) * s + time * 4;
                ctx.fillStyle = spkColor;
                ctx.fillRect(Math.cos(sa) * 10, -jSize * 0.5 + Math.sin(sa) * 8, 2, 2);
            }
        }
        ctx.restore();
    }

    // --- Character carrying a basket of grass (walking along mountain) ---
    {
        const cSpeed = 15;
        const carrierX = ((time * cSpeed + 300) % (W * 0.6)) + W * 0.2;
        // Follow the second mountain layer roughly
        const carrierY = H * 0.38 + Math.sin(carrierX * 0.005 + 4) * (-40) + Math.sin(carrierX * 0.012 + 2) * (-25) + 38;
        const cSize = 7;
        const cWalk = Math.sin(time * 5) * 1.5;
        const cLeg = Math.sin(time * 10) * 2;
        const cColor = nightMode ? '#7a9a70' : '#15803d';

        ctx.save(); ctx.translate(carrierX, carrierY);
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fillRect(-cSize * 0.5, cSize * 0.08, cSize, cSize * 0.12);
        ctx.fillStyle = darkenColor(cColor, 30);
        ctx.fillRect(-cSize * 0.18 + cLeg * 0.2, -cSize * 0.04, cSize * 0.14, cSize * 0.25);
        ctx.fillRect(cSize * 0.06 - cLeg * 0.2, -cSize * 0.04, cSize * 0.14, cSize * 0.25);
        ctx.fillStyle = cColor;
        ctx.fillRect(-cSize * 0.22, -cSize * 0.55 + cWalk * 0.15, cSize * 0.44, cSize * 0.5);
        ctx.fillStyle = lightenColor(cColor, 20);
        ctx.fillRect(-cSize * 0.18, -cSize * 0.78 + cWalk * 0.15, cSize * 0.36, cSize * 0.26);
        // Basket on back
        ctx.fillStyle = nightMode ? '#5a4a30' : '#a0855a';
        ctx.fillRect(-cSize * 0.4, -cSize * 0.7 + cWalk * 0.15, cSize * 0.22, cSize * 0.35);
        // Grass poking out of basket
        ctx.fillStyle = '#4ade80';
        ctx.fillRect(-cSize * 0.42, -cSize * 0.85 + cWalk * 0.15, cSize * 0.08, cSize * 0.18);
        ctx.fillRect(-cSize * 0.32, -cSize * 0.9 + cWalk * 0.15, cSize * 0.08, cSize * 0.22);
        ctx.fillRect(-cSize * 0.22, -cSize * 0.82 + cWalk * 0.15, cSize * 0.08, cSize * 0.15);
        ctx.restore();
    }

    // --- Fisherman sitting by a small pond (right side, mid area) ---
    {
        const fx = W * 0.88, fy = H * 0.52;
        const bobTime = Math.sin(time * 1.5) * 2;
        const fSize = 7;
        const fColor = nightMode ? '#6677aa' : '#1d4ed8';

        // Small pond
        ctx.fillStyle = nightMode ? 'rgba(30,40,80,0.6)' : 'rgba(80,150,220,0.5)';
        ctx.beginPath(); ctx.ellipse(fx + 18, fy + 2, 14, 5, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = nightMode ? 'rgba(50,60,100,0.3)' : 'rgba(150,200,255,0.3)';
        ctx.beginPath(); ctx.ellipse(fx + 16, fy, 8, 3, 0, 0, Math.PI * 2); ctx.fill();

        // Character sitting
        ctx.save(); ctx.translate(fx, fy);
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(-fSize * 0.4, fSize * 0.05, fSize * 0.8, fSize * 0.1);
        // Sitting legs (horizontal)
        ctx.fillStyle = darkenColor(fColor, 30);
        ctx.fillRect(-fSize * 0.1, -fSize * 0.08, fSize * 0.45, fSize * 0.15);
        // Body (hunched)
        ctx.fillStyle = fColor;
        ctx.fillRect(-fSize * 0.22, -fSize * 0.5, fSize * 0.44, fSize * 0.45);
        // Head
        ctx.fillStyle = lightenColor(fColor, 20);
        ctx.fillRect(-fSize * 0.18, -fSize * 0.72, fSize * 0.36, fSize * 0.25);
        // Hat
        ctx.fillStyle = nightMode ? '#4a3a2a' : '#92400e';
        ctx.fillRect(-fSize * 0.25, -fSize * 0.8, fSize * 0.5, fSize * 0.1);
        ctx.fillRect(-fSize * 0.15, -fSize * 0.9, fSize * 0.3, fSize * 0.12);
        // Fishing rod
        ctx.strokeStyle = nightMode ? '#6a5a40' : '#8B4513';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(fSize * 0.2, -fSize * 0.35);
        ctx.lineTo(fSize * 2.5, -fSize * 1.2 + bobTime);
        ctx.stroke();
        // Fishing line
        ctx.strokeStyle = nightMode ? 'rgba(150,160,200,0.4)' : 'rgba(100,100,100,0.5)';
        ctx.lineWidth = 0.6;
        ctx.beginPath();
        ctx.moveTo(fSize * 2.5, -fSize * 1.2 + bobTime);
        ctx.lineTo(fSize * 2.6, fSize * 0.1 + bobTime * 0.5);
        ctx.stroke();
        // Float bobbing
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(fSize * 2.4, fSize * 0.0 + bobTime * 0.5, 3, 3);
        ctx.restore();
    }

    // --- Tiny pixel character doing push-ups (near mid-ground) ---
    {
        const px2 = W * 0.15, py2 = H * 0.48;
        const pushUp = Math.abs(Math.sin(time * 3));
        const pSize = 6;
        const pColor = nightMode ? '#8a7acc' : '#dc2626';

        ctx.save(); ctx.translate(px2, py2);
        // Ground shadow
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(-pSize * 0.7, pSize * 0.05 + pushUp * 1.5, pSize * 1.4, pSize * 0.1);
        // Body horizontal (push-up position)
        const bodyY = -pSize * 0.15 + pushUp * 1.5;
        // Arms (holding up)
        ctx.fillStyle = darkenColor(pColor, 30);
        ctx.fillRect(-pSize * 0.45, bodyY, pSize * 0.12, pSize * 0.15 + pushUp * 1.5);
        ctx.fillRect(pSize * 0.35, bodyY, pSize * 0.12, pSize * 0.15 + pushUp * 1.5);
        // Horizontal body
        ctx.fillStyle = pColor;
        ctx.fillRect(-pSize * 0.5, bodyY - pSize * 0.12, pSize * 1.0, pSize * 0.2);
        // Head
        ctx.fillStyle = lightenColor(pColor, 20);
        ctx.fillRect(-pSize * 0.6, bodyY - pSize * 0.25, pSize * 0.2, pSize * 0.2);
        // Sweat drop
        if (pushUp > 0.7) {
            ctx.fillStyle = nightMode ? '#aabbee' : '#60a5fa';
            ctx.fillRect(-pSize * 0.7, bodyY - pSize * 0.35 - Math.sin(time * 8) * 2, 2, 3);
        }
        ctx.restore();
    }

    // ‚ïê‚ïê‚ïê MISTY MOUNTAIN SILHOUETTES ‚ïê‚ïê‚ïê
    const groundY = H * 0.88;
    const mtColors = nightMode
        ? ['#151b2e', '#1a2338', '#202b44']
        : ['#5a7a6a', '#4a6b5a', '#6a8a7a'];
    for (let layer = 0; layer < 3; layer++) {
        const yBase = H * 0.3 + layer * H * 0.08;
        ctx.fillStyle = mtColors[layer];
        ctx.beginPath();
        ctx.moveTo(0, yBase + 40);
        for (let mx = 0; mx <= W; mx += 20) {
            const mh = Math.sin(mx * 0.005 + layer * 2) * 40 + Math.sin(mx * 0.012 + layer) * 25;
            ctx.lineTo(mx, yBase - mh);
        }
        ctx.lineTo(W, H); ctx.lineTo(0, H);
        ctx.closePath(); ctx.fill();
    }

    // ‚ïê‚ïê‚ïê FAR BACKGROUND TREES (silhouettes, misty) ‚ïê‚ïê‚ïê
    const farTreePositions = [
        { x: W * 0.05, h: 110, type: 'pine' }, { x: W * 0.12, h: 140, type: 'tall' },
        { x: W * 0.22, h: 160, type: 'pine' }, { x: W * 0.30, h: 130, type: 'pine' },
        { x: W * 0.40, h: 150, type: 'tall' }, { x: W * 0.52, h: 170, type: 'pine' },
        { x: W * 0.60, h: 120, type: 'pine' }, { x: W * 0.70, h: 155, type: 'tall' },
        { x: W * 0.80, h: 135, type: 'pine' }, { x: W * 0.90, h: 145, type: 'pine' },
        { x: W * 0.97, h: 125, type: 'tall' },
    ];
    const farBaseY = H * 0.62;
    const farSway = Math.sin(time * 0.4) * 1.5;
    const farColors = nightMode
        ? ['#1a2540', '#1e2d4a', '#223355']
        : ['#2d5a3a', '#336644', '#2a4f35'];
    const farTrunk = nightMode ? '#151d30' : '#3a2a1a';

    farTreePositions.forEach(t => {
        if (t.type === 'pine') {
            drawPineTree(ctx, t.x, farBaseY, t.h, t.h * 0.45, 6, 25, farColors, farTrunk, farSway);
        } else {
            drawTallTree(ctx, t.x, farBaseY, t.h * 0.5, t.h * 0.25, farColors, farTrunk, farSway);
        }
    });

    // Mist overlay on far trees
    const mistGrad = ctx.createLinearGradient(0, farBaseY - 100, 0, farBaseY + 30);
    if (nightMode) {
        mistGrad.addColorStop(0, 'rgba(15,20,40,0)');
        mistGrad.addColorStop(1, 'rgba(15,20,40,0.5)');
    } else {
        mistGrad.addColorStop(0, 'rgba(180,200,190,0)');
        mistGrad.addColorStop(1, 'rgba(180,200,190,0.35)');
    }
    ctx.fillStyle = mistGrad;
    ctx.fillRect(0, farBaseY - 180, W, 220);

    // ‚ïê‚ïê‚ïê MID-GROUND TREES ‚ïê‚ïê‚ïê
    const midBaseY = H * 0.75;
    const midSway = Math.sin(time * 0.6 + 1) * 2.5;
    const midPineColors = nightMode
        ? ['#1d3328', '#254035', '#1a3020', '#2a4a38']
        : ['#2d6b3a', '#3a7a4a', '#257a35', '#4a8a55'];
    const midTallColors = nightMode
        ? ['#1a3825', '#22442e', '#1d3a28']
        : ['#45a049', '#3d8b40', '#55b855'];
    const midTrunk = nightMode ? '#2a1f18' : '#5a3a20';

    const midTrees = [
        { x: W * 0.02, h: 130, type: 'pine' as const },
        { x: W * 0.08, h: 180, type: 'tall' as const },
        { x: W * 0.18, h: 150, type: 'pine' as const },
        { x: W * 0.25, h: 110, type: 'pine' as const },
        { x: W * 0.35, h: 190, type: 'tall' as const },
        { x: W * 0.45, h: 140, type: 'pine' as const },
        { x: W * 0.55, h: 170, type: 'pine' as const },
        { x: W * 0.65, h: 200, type: 'tall' as const },
        { x: W * 0.75, h: 145, type: 'pine' as const },
        { x: W * 0.85, h: 165, type: 'pine' as const },
        { x: W * 0.95, h: 185, type: 'tall' as const },
    ];
    midTrees.forEach(t => {
        // Skip trees that would overlap the arena too much
        const inArena = t.x > offsetX - 30 && t.x < offsetX + ARENA_W + 30
            && midBaseY > offsetY - 30 && midBaseY < offsetY + ARENA_H + 30;
        if (inArena) return;
        if (t.type === 'pine') {
            drawPineTree(ctx, t.x, midBaseY, t.h, t.h * 0.4, 8, 35, midPineColors, midTrunk, midSway);
        } else {
            drawTallTree(ctx, t.x, midBaseY, t.h * 0.55, t.h * 0.22, midTallColors, midTrunk, midSway);
        }
    });

    // ‚ïê‚ïê‚ïê GROUND PLANE ‚ïê‚ïê‚ïê
    const groundGrad = ctx.createLinearGradient(0, groundY - 30, 0, H);
    if (nightMode) {
        groundGrad.addColorStop(0, '#1a2a18');
        groundGrad.addColorStop(0.3, '#162214');
        groundGrad.addColorStop(1, '#0e160d');
    } else {
        groundGrad.addColorStop(0, '#4a7a3a');
        groundGrad.addColorStop(0.3, '#3a6a2a');
        groundGrad.addColorStop(1, '#2a5a1a');
    }
    ctx.fillStyle = groundGrad;
    ctx.fillRect(0, groundY - 20, W, H - groundY + 20);

    // Ground texture dots
    const dotColor = nightMode ? 'rgba(40,60,35,0.5)' : 'rgba(80,130,60,0.4)';
    ctx.fillStyle = dotColor;
    for (let i = 0; i < 60; i++) {
        const dx = ((i * 73 + 17) % 100) / 100 * W;
        const dy = groundY + ((i * 41 + 7) % 100) / 100 * (H - groundY);
        ctx.fillRect(dx, dy, 3, 2);
    }

    // ‚ïê‚ïê‚ïê WALKING PIXEL CHARACTERS ‚ïê‚ïê‚ïê
    const charPositions = [
        { baseX: 120, y: groundY - 2, size: 10, color: '#ef4444', speed: 4, range: 80 },
        { baseX: W - 180, y: groundY - 2, size: 9, color: '#3b82f6', speed: 3.5, range: 60 },
        { baseX: W * 0.45, y: groundY + 15, size: 8, color: '#22c55e', speed: 5, range: 50 },
        { baseX: 60, y: groundY + 25, size: 7, color: '#eab308', speed: 3, range: 40 },
    ];
    charPositions.forEach(ch => {
        const charX = ch.baseX + Math.sin(time * 0.5 * ch.speed / 4) * ch.range;
        // Only draw if outside arena
        if (charX > offsetX - 10 && charX < offsetX + ARENA_W + 10 && ch.y > offsetY - 10 && ch.y < offsetY + ARENA_H + 10) return;
        drawWalkingChar(ctx, charX, ch.y, ch.size, ch.color, time, ch.speed);
    });

    // ‚ïê‚ïê‚ïê ROCKS & DETAILS ‚ïê‚ïê‚ïê
    const rocks = [
        { x: W * 0.78, y: groundY, w: 28, h: 22 },
        { x: W * 0.15, y: groundY + 10, w: 22, h: 16 },
        { x: W * 0.55, y: groundY + 30, w: 18, h: 14 },
    ];
    rocks.forEach(r => {
        if (r.x > offsetX - 10 && r.x < offsetX + ARENA_W + 10 && r.y > offsetY - 10 && r.y < offsetY + ARENA_H + 10) return;
        drawRock(ctx, r.x, r.y, r.w, r.h, nightMode);
    });

    // ‚ïê‚ïê‚ïê MUSHROOMS ‚ïê‚ïê‚ïê
    const mushrooms = [
        { x: W * 0.10, y: groundY - 2 },
        { x: W * 0.88, y: groundY + 8 },
        { x: W * 0.42, y: groundY + 20 },
    ];
    mushrooms.forEach(m => {
        if (m.x > offsetX - 10 && m.x < offsetX + ARENA_W + 10 && m.y > offsetY - 10 && m.y < offsetY + ARENA_H + 10) return;
        // Stem
        ctx.fillStyle = nightMode ? '#c4a882' : '#f5deb3';
        ctx.fillRect(m.x - 2, m.y - 8, 4, 8);
        // Cap
        ctx.fillStyle = nightMode ? '#8b2020' : '#e74c3c';
        ctx.beginPath(); ctx.arc(m.x, m.y - 9, 7, Math.PI, 0); ctx.fill();
        // Spots
        ctx.fillStyle = '#fff';
        ctx.fillRect(m.x - 3, m.y - 12, 2, 2);
        ctx.fillRect(m.x + 2, m.y - 11, 2, 2);
    });

    // ‚ïê‚ïê‚ïê GRASS TUFTS ‚ïê‚ïê‚ïê
    const grassSway = Math.sin(time * 1.8) * 3;
    const grassColor1 = nightMode ? '#2a5a28' : '#5fcc37';
    const grassColor2 = nightMode ? '#1d4a1a' : '#4bb82a';
    const grassColor3 = nightMode ? '#3a6a35' : '#7ae650';
    const tufts = [
        { x: 40, y: groundY, w: 20, h: 14 }, { x: 100, y: groundY - 2, w: 25, h: 16 },
        { x: 200, y: groundY + 5, w: 18, h: 12 }, { x: 320, y: groundY - 1, w: 22, h: 15 },
        { x: W - 80, y: groundY, w: 20, h: 14 }, { x: W - 150, y: groundY + 3, w: 24, h: 13 },
        { x: W - 250, y: groundY - 2, w: 18, h: 16 }, { x: W * 0.5 - 200, y: groundY + 8, w: 20, h: 12 },
        { x: W * 0.5 + 200, y: groundY + 12, w: 22, h: 14 }, { x: W * 0.5, y: groundY - 3, w: 26, h: 18 },
    ];
    tufts.forEach((t, i) => {
        if (t.x > offsetX - 10 && t.x < offsetX + ARENA_W + 10 && t.y > offsetY - 10 && t.y < offsetY + ARENA_H + 10) return;
        const c = [grassColor1, grassColor2, grassColor3][i % 3];
        drawGrassTuft(ctx, t.x, t.y, t.w, t.h, c, grassSway * (0.5 + i * 0.1));
    });

    // ‚ïê‚ïê‚ïê FOREGROUND TREES (larger, in front) ‚ïê‚ïê‚ïê
    const fgSway = Math.sin(time * 0.5 + 2) * 3;
    const fgPineColors = nightMode
        ? ['#152a18', '#1d3820', '#1a3018', '#254530']
        : ['#1a6b2a', '#2d8a3a', '#3da848', '#238830'];
    const fgTallColors = nightMode
        ? ['#183020', '#204028', '#1a3520']
        : ['#2d8b30', '#45a049', '#3d9a40'];
    const fgTrunk = nightMode ? '#2a1a10' : '#6b4226';

    const fgTrees = [
        { x: -15, h: 250, type: 'tall' as const },
        { x: W * 0.06, h: 180, type: 'pine' as const },
        { x: W - 30, h: 240, type: 'tall' as const },
        { x: W * 0.94, h: 170, type: 'pine' as const },
    ];
    fgTrees.forEach(t => {
        if (t.type === 'pine') {
            drawPineTree(ctx, t.x, groundY, t.h, t.h * 0.35, 10, 45, fgPineColors, fgTrunk, fgSway);
        } else {
            drawTallTree(ctx, t.x, groundY, t.h * 0.6, t.h * 0.2, fgTallColors, fgTrunk, fgSway);
        }
    });

    // ‚ïê‚ïê‚ïê FIREFLY / PARTICLE EFFECTS ‚ïê‚ïê‚ïê
    const particleCount = nightMode ? 25 : 12;
    for (let i = 0; i < particleCount; i++) {
        const seed1 = ((i * 127 + 53) % 100) / 100;
        const seed2 = ((i * 89 + 31) % 100) / 100;
        const px = seed1 * W;
        const py = H * 0.3 + seed2 * H * 0.6;
        // Skip if inside arena
        if (px > offsetX - 5 && px < offsetX + ARENA_W + 5 && py > offsetY - 5 && py < offsetY + ARENA_H + 5) continue;
        const drift = Math.sin(time * 1.2 + i * 0.8) * 8;
        const driftY = Math.cos(time * 0.9 + i * 1.1) * 5;
        const flicker = 0.3 + 0.7 * Math.abs(Math.sin(time * 2.5 + i * 1.3));

        if (nightMode) {
            // Glowing fireflies
            ctx.fillStyle = `rgba(200,255,100,${flicker * 0.5})`;
            ctx.beginPath(); ctx.arc(px + drift, py + driftY, 4, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = `rgba(255,255,180,${flicker * 0.8})`;
            ctx.beginPath(); ctx.arc(px + drift, py + driftY, 2, 0, Math.PI * 2); ctx.fill();
        } else {
            // Floating pollen / dust motes
            ctx.fillStyle = `rgba(255,255,220,${flicker * 0.3})`;
            ctx.beginPath(); ctx.arc(px + drift, py + driftY, 2, 0, Math.PI * 2); ctx.fill();
        }
    }

    // ‚ïê‚ïê‚ïê LIGHT RAYS (day mode) ‚ïê‚ïê‚ïê
    if (!nightMode) {
        ctx.save();
        for (let r = 0; r < 5; r++) {
            const rayX = W * 0.2 + r * W * 0.15;
            const rayAlpha = 0.03 + 0.02 * Math.sin(time * 0.5 + r);
            const grad = ctx.createLinearGradient(rayX, 0, rayX + 60, H);
            grad.addColorStop(0, `rgba(255,255,200,${rayAlpha})`);
            grad.addColorStop(0.5, `rgba(255,255,200,${rayAlpha * 0.5})`);
            grad.addColorStop(1, 'rgba(255,255,200,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(rayX, 0);
            ctx.lineTo(rayX + 40, 0);
            ctx.lineTo(rayX + 100, H);
            ctx.lineTo(rayX + 20, H);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    }

    // ‚ïê‚ïê‚ïê ATMOSPHERIC FOG LAYER ‚ïê‚ïê‚ïê
    const fogGrad = ctx.createLinearGradient(0, H * 0.6, 0, H);
    if (nightMode) {
        fogGrad.addColorStop(0, 'rgba(10,15,25,0)');
        fogGrad.addColorStop(1, 'rgba(10,15,25,0.4)');
    } else {
        fogGrad.addColorStop(0, 'rgba(60,100,70,0)');
        fogGrad.addColorStop(1, 'rgba(40,80,50,0.25)');
    }
    ctx.fillStyle = fogGrad;
    ctx.fillRect(0, H * 0.6, W, H * 0.4);

    // ‚ïê‚ïê‚ïê ARENA DECORATIVE BORDER ‚ïê‚ïê‚ïê
    ctx.save();
    ctx.translate(offsetX, offsetY);

    // Corner flag posts
    const flags = [[0, 0], [ARENA_W, 0], [0, ARENA_H], [ARENA_W, ARENA_H]] as [number, number][];
    flags.forEach(([fx, fy]) => {
        ctx.fillStyle = nightMode ? '#94a3b8' : '#e2e8f0';
        ctx.fillRect(fx - 2, fy - 18, 4, 18);
        ctx.fillStyle = nightMode ? '#f59e0b' : '#ef4444';
        ctx.beginPath();
        ctx.moveTo(fx + 2, fy - 18);
        ctx.lineTo(fx + 14, fy - 13);
        ctx.lineTo(fx + 2, fy - 8);
        ctx.closePath(); ctx.fill();
    });

    // Arena boundary
    const borderColors = nightMode
        ? ['#6366f1', '#818cf8']
        : ['#f59e0b', '#fbbf24'];
    ctx.strokeStyle = borderColors[0];
    ctx.lineWidth = 6;
    ctx.strokeRect(-3, -3, ARENA_W + 6, ARENA_H + 6);
    ctx.strokeStyle = borderColors[1];
    ctx.lineWidth = 2;
    ctx.strokeRect(-8, -8, ARENA_W + 16, ARENA_H + 16);

    // Center circle
    ctx.strokeStyle = nightMode ? 'rgba(129,140,248,0.3)' : 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 6]);
    ctx.beginPath(); ctx.arc(ARENA_W / 2, ARENA_H / 2, 60, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ARENA_W / 2 - 15, ARENA_H / 2); ctx.lineTo(ARENA_W / 2 + 15, ARENA_H / 2);
    ctx.moveTo(ARENA_W / 2, ARENA_H / 2 - 15); ctx.lineTo(ARENA_W / 2, ARENA_H / 2 + 15);
    ctx.stroke();
    ctx.setLineDash([]);

    // Subtle grid lines
    ctx.strokeStyle = nightMode ? 'rgba(129,140,248,0.08)' : 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;
    for (let col = 1; col < GRID_COLS; col++) {
        ctx.beginPath();
        ctx.moveTo(col * TILE_SIZE, 0);
        ctx.lineTo(col * TILE_SIZE, ARENA_H);
        ctx.stroke();
    }
    for (let row = 1; row < GRID_ROWS; row++) {
        ctx.beginPath();
        ctx.moveTo(0, row * TILE_SIZE);
        ctx.lineTo(ARENA_W, row * TILE_SIZE);
        ctx.stroke();
    }

    ctx.restore();
}

function drawHex(ctx: CanvasRenderingContext2D, cx: number, cy: number, r: number) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i;
        const x = cx + r * Math.cos(a);
        const y = cy + r * Math.sin(a);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath(); ctx.stroke();
}

const TILE_SIZE_CONST = TILE_SIZE;
const ARENA_W_CONST = ARENA_W;
const ARENA_H_CONST = ARENA_H;

export const GameArena: React.FC<GameArenaProps> = ({ room, nightMode, setNightMode, onLeave }) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [gameState, setGameState] = useState<any>(room.state);
    const [showEndScreen, setShowEndScreen] = useState(false);
    const [lastEvent, setLastEvent] = useState("");
    const [eventIcon, setEventIcon] = useState<'bomb' | 'rocket' | 'speed' | ''>('');


    // Cached tiles
    const grassTileRef = useRef<HTMLCanvasElement | null>(null);
    const smallGrassTileRef = useRef<HTMLCanvasElement | null>(null);
    const dirtTileRef = useRef<HTMLCanvasElement | null>(null);

    // Visual effects state
    const vfxRef = useRef<VFX[]>([]);
    const rocketsRef = useRef<RocketProjectile[]>([]);
    const floatingTextsRef = useRef<FloatingText[]>([]);
    const speedParticlesRef = useRef<SpeedParticle[]>([]);
    const playerColorsRef = useRef<Map<string, string>>(new Map());
    const colorIndexRef = useRef(0);
    const vfxIdRef = useRef(0);
    const prevScoresRef = useRef<Map<string, number>>(new Map());
    const collectedTilesRef = useRef<Set<string>>(new Set());
    const prevGrassKeysRef = useRef<Set<string>>(new Set());
    const timeRef = useRef(0);

    const getPlayerColor = useCallback((sessionId: string, playerAvatarColor?: string): string => {
        if (playerAvatarColor) return playerAvatarColor;
        if (!playerColorsRef.current.has(sessionId)) {
            playerColorsRef.current.set(sessionId, PLAYER_COLORS[colorIndexRef.current % PLAYER_COLORS.length]);
            colorIndexRef.current++;
        }
        return playerColorsRef.current.get(sessionId)!;
    }, []);

    // Init tiles
    useEffect(() => {
        grassTileRef.current = makeDahliaTile(TILE_SIZE);
        smallGrassTileRef.current = makeSmallGrassTile(TILE_SIZE);
        dirtTileRef.current = makeDirtTile(TILE_SIZE);
    }, []);

    // Input handling
    useEffect(() => {
        const keys: { [key: string]: boolean } = {};

        const handleKeyDown = (e: KeyboardEvent) => {
            keys[e.key] = true;
            updateMovement();
        };

        const handleKeyUp = (e: KeyboardEvent) => {
            keys[e.key] = false;
            updateMovement();
        };

        const updateMovement = () => {
            let dx = 0, dy = 0;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) dx -= 1;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) dx += 1;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) dy -= 1;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) dy += 1;
            room.send("move", { dx, dy });
        };

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        return () => {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
        };
    }, [room]);

    // Room state sync + VFX triggers
    useEffect(() => {
        room.onStateChange((state) => {
            setGameState({ ...state });
            if (state.matchEnded) {
                setShowEndScreen(true);
            } else {
                setShowEndScreen(false);
            }

            if (state.lastEvent && state.lastEvent !== lastEvent) {
                setLastEvent(state.lastEvent);
                const evt = state.lastEvent as string;

                if (evt.includes('Bomb')) {
                    setEventIcon('bomb');
                    state.players?.forEach((player: any) => {
                        if (evt.includes(player.displayName)) {
                            spawnBombVFX(player.x, player.y);
                        }
                    });
                } else if (evt.includes('Rocket')) {
                    setEventIcon('rocket');
                    state.players?.forEach((player: any, sid: string) => {
                        if (evt.includes(player.displayName)) {
                            spawnRocketVFX(player.x, player.y, getPlayerColor(sid, player.color));
                        }
                    });
                } else if (evt.includes('Speed')) {
                    setEventIcon('speed');
                    state.players?.forEach((player: any, sid: string) => {
                        if (evt.includes(player.displayName)) {
                            spawnSpeedVFX(player.x, player.y, getPlayerColor(sid, player.color));
                        }
                    });
                } else {
                    setEventIcon('');
                }

                setTimeout(() => setEventIcon(''), 3000);
            }

            state.players?.forEach((player: any, sid: string) => {
                const prevScore = prevScoresRef.current.get(sid) || 0;
                if (player.score > prevScore) {
                    floatingTextsRef.current.push({
                        id: vfxIdRef.current++,
                        x: player.x,
                        y: player.y - 40,
                        text: `+${player.score - prevScore}`,
                        color: '#4ade80',
                        timer: 1.2,
                    });
                }
                prevScoresRef.current.set(sid, player.score);

                // Speed particle trail
                if (player.speedMultiplier > 1) {
                    const color = getPlayerColor(sid, player.color);
                    for (let i = 0; i < 2; i++) {
                        speedParticlesRef.current.push({
                            id: vfxIdRef.current++,
                            x: player.x + (Math.random() - 0.5) * 20,
                            y: player.y + (Math.random() - 0.5) * 20,
                            vx: (Math.random() - 0.5) * 60,
                            vy: (Math.random() - 0.5) * 60 - 20,
                            timer: 0.5 + Math.random() * 0.3,
                            maxTimer: 0.8,
                            color,
                        });
                    }
                }
            });
        });

        return () => { room.removeAllListeners(); };
    }, [room, lastEvent, getPlayerColor]);

    const spawnBombVFX = (x: number, y: number) => {
        // Shockwave rings
        vfxRef.current.push({ id: vfxIdRef.current++, type: 'bomb', x, y, timer: 1.8, maxTimer: 1.8 });
        // Debris particles
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i;
            speedParticlesRef.current.push({
                id: vfxIdRef.current++,
                x, y,
                vx: Math.cos(angle) * (80 + Math.random() * 80),
                vy: Math.sin(angle) * (80 + Math.random() * 80),
                timer: 1.0 + Math.random() * 0.5,
                maxTimer: 1.5,
                color: i % 2 === 0 ? '#ef4444' : '#f97316',
            });
        }
    };

    const spawnRocketVFX = (x: number, y: number, color: string) => {
        // 8 rockets in all directions
        const directions = [
            { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 },
            { dx: -0.707, dy: -0.707 }, { dx: 0.707, dy: -0.707 },
            { dx: -0.707, dy: 0.707 }, { dx: 0.707, dy: 0.707 }
        ];
        directions.forEach(d => {
            rocketsRef.current.push({
                id: vfxIdRef.current++,
                x, y,
                dx: d.dx * 320,
                dy: d.dy * 320,
                timer: 2.2,
                trail: [],
            });
        });
        // Central explosion flash
        vfxRef.current.push({ id: vfxIdRef.current++, type: 'rocket', x, y, timer: 0.8, maxTimer: 0.8 });
    };

    const spawnSpeedVFX = (x: number, y: number, color: string) => {
        vfxRef.current.push({ id: vfxIdRef.current++, type: 'speed', x, y, timer: 2.0, maxTimer: 2.0 });
        // Burst of lightning-yellow particles upward
        for (let i = 0; i < 16; i++) {
            const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
            speedParticlesRef.current.push({
                id: vfxIdRef.current++,
                x: x + (Math.random() - 0.5) * 20,
                y,
                vx: Math.cos(angle) * (60 + Math.random() * 80),
                vy: Math.sin(angle) * (100 + Math.random() * 60),
                timer: 0.8 + Math.random() * 0.4,
                maxTimer: 1.2,
                color: '#fbbf24',
            });
        }
    };

    // Canvas Rendering
    useEffect(() => {
        if (!canvasRef.current || !gameState) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d')!;
        if (!ctx) return;

        let animationFrameId: number;
        let lastTime = performance.now();

        const render = (now: number) => {
            const dt = Math.min((now - lastTime) / 1000, 0.05);
            lastTime = now;
            timeRef.current += dt;
            const time = timeRef.current;

            const W = 1200;
            const H = 900;
            canvas.width = W;
            canvas.height = H;

            const offsetX = (W - ARENA_W) / 2;
            const offsetY = (H - ARENA_H) / 2;

            ctx.clearRect(0, 0, W, H);

            // ‚îÄ‚îÄ DRAW BACKGROUND ‚îÄ‚îÄ
            drawArenaBackground(ctx, W, H, offsetX, offsetY, nightMode, time);

            ctx.save();
            ctx.translate(offsetX, offsetY);

            // ‚îÄ‚îÄ ARENA GROUND: TWO-PHASE GRASS TILES ‚îÄ‚îÄ
            if (grassTileRef.current && dirtTileRef.current && smallGrassTileRef.current) {
                // Build a map of tile positions ‚Üí grass data from server
                const tileMap = new Map<string, { phase: number; powerUp: string }>();
                if (gameState.grasses) {
                    gameState.grasses.forEach((g: any) => {
                        const tx = Math.floor(g.x / TILE_SIZE);
                        const ty = Math.floor(g.y / TILE_SIZE);
                        tileMap.set(`${tx},${ty}`, { phase: g.phase || 1, powerUp: g.powerUp || '' });
                    });
                }

                // Draw all 12x8 tiles
                for (let ty = 0; ty < GRID_ROWS; ty++) {
                    for (let tx = 0; tx < GRID_COLS; tx++) {
                        const x = tx * TILE_SIZE;
                        const y = ty * TILE_SIZE;
                        const key = `${tx},${ty}`;
                        const tileData = tileMap.get(key);

                        if (!tileData) {
                            // Fully collected ‚Äî show dirt
                            ctx.drawImage(dirtTileRef.current, x, y, TILE_SIZE, TILE_SIZE);
                        } else if (tileData.phase === 1) {
                            // Phase 1 ‚Äî big grass
                            ctx.drawImage(grassTileRef.current, x, y, TILE_SIZE, TILE_SIZE);
                        } else if (tileData.phase === 2) {
                            // Phase 2 ‚Äî small grass on dirt
                            ctx.drawImage(smallGrassTileRef.current, x, y, TILE_SIZE, TILE_SIZE);

                            // Draw hidden power-up icon if this tile has one
                            if (tileData.powerUp) {
                                drawPowerUpIcon(ctx, x + TILE_SIZE / 2, y + TILE_SIZE / 2, tileData.powerUp, time);
                            }
                        }
                    }
                }
            }

            // ‚îÄ‚îÄ UPDATE & DRAW SPEED PARTICLES ‚îÄ‚îÄ
            speedParticlesRef.current = speedParticlesRef.current.filter(p => {
                p.timer -= dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 150 * dt; // gravity
                return p.timer > 0;
            });
            speedParticlesRef.current.forEach(p => {
                const alpha = p.timer / p.maxTimer;
                const size = 4 * alpha;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // ‚îÄ‚îÄ UPDATE & DRAW ROCKETS ‚îÄ‚îÄ
            rocketsRef.current = rocketsRef.current.filter(r => {
                r.timer -= dt;
                // Store trail
                r.trail.push({ x: r.x, y: r.y, alpha: 1.0 });
                if (r.trail.length > 12) r.trail.shift();
                r.trail.forEach(t => { t.alpha -= dt * 3; });
                r.x += r.dx * dt;
                r.y += r.dy * dt;
                return r.timer > 0;
            });

            rocketsRef.current.forEach(rocket => {
                // Draw trail
                rocket.trail.forEach((t, i) => {
                    const a = Math.max(0, t.alpha) * (i / rocket.trail.length);
                    ctx.globalAlpha = a * 0.6;
                    ctx.fillStyle = '#f97316';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 3 * (i / rocket.trail.length), 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw rocket body
                const angle = Math.atan2(rocket.dy, rocket.dx);
                ctx.save();
                ctx.translate(rocket.x, rocket.y);
                ctx.rotate(angle + Math.PI / 2);

                // Flame
                ctx.fillStyle = '#fbbf24';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(-3, 8);
                ctx.lineTo(0, 14 + Math.random() * 4);
                ctx.lineTo(3, 8);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Body
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(-3, -9, 6, 14);
                // Nose cone
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.moveTo(-3, -9);
                ctx.lineTo(0, -16);
                ctx.lineTo(3, -9);
                ctx.fill();
                // Fins
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.moveTo(-3, 4); ctx.lineTo(-7, 8); ctx.lineTo(-3, 8); ctx.fill();
                ctx.beginPath();
                ctx.moveTo(3, 4); ctx.lineTo(7, 8); ctx.lineTo(3, 8); ctx.fill();

                ctx.restore();
            });

            // ‚îÄ‚îÄ UPDATE & DRAW VFX ‚îÄ‚îÄ
            vfxRef.current = vfxRef.current.filter(v => { v.timer -= dt; return v.timer > 0; });

            vfxRef.current.forEach(v => {
                const progress = 1 - v.timer / v.maxTimer;

                if (v.type === 'bomb') {
                    // Phase 1: bomb emoji bounce
                    if (progress < 0.25) {
                        const scale = 1 + Math.sin(progress * Math.PI / 0.25) * 1.5;
                        ctx.save();
                        ctx.font = `${24 * scale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üí£', v.x, v.y - 20 * scale);
                        ctx.restore();
                    }
                    // Phase 2: expanding shockwave rings
                    else {
                        const exp = (progress - 0.25) / 0.75;
                        const maxR = 80;

                        // Multiple rings for impact
                        for (let ring = 0; ring < 3; ring++) {
                            const rProgress = Math.max(0, exp - ring * 0.15);
                            const r = rProgress * maxR;
                            const a = (1 - rProgress) * 0.8;
                            if (a > 0) {
                                ctx.globalAlpha = a;
                                ctx.strokeStyle = ring === 0 ? '#ef4444' : ring === 1 ? '#f97316' : '#fbbf24';
                                ctx.lineWidth = 4 - ring;
                                ctx.beginPath(); ctx.arc(v.x, v.y, r, 0, Math.PI * 2); ctx.stroke();
                            }
                        }

                        // Flash center
                        ctx.globalAlpha = Math.max(0, (1 - exp) * 0.5);
                        const flashGrad = ctx.createRadialGradient(v.x, v.y, 0, v.x, v.y, 30);
                        flashGrad.addColorStop(0, '#fff');
                        flashGrad.addColorStop(0.3, '#fbbf24');
                        flashGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = flashGrad;
                        ctx.beginPath(); ctx.arc(v.x, v.y, 30, 0, Math.PI * 2); ctx.fill();
                        ctx.globalAlpha = 1;

                        // üí• text popup
                        if (exp < 0.4) {
                            const textAlpha = 1 - exp / 0.4;
                            ctx.globalAlpha = textAlpha;
                            ctx.font = `bold ${20 + exp * 20}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillStyle = '#fbbf24';
                            ctx.fillText('üí•', v.x, v.y - 30 - exp * 30);
                            ctx.globalAlpha = 1;
                        }
                    }
                    ctx.globalAlpha = 1;
                }

                else if (v.type === 'rocket') {
                    // Central launch explosion
                    const r = progress * 50;
                    const a = 1 - progress;
                    ctx.globalAlpha = a;
                    // Outer ring
                    ctx.strokeStyle = '#f97316';
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(v.x, v.y, r, 0, Math.PI * 2); ctx.stroke();
                    // Inner flash
                    const g = ctx.createRadialGradient(v.x, v.y, 0, v.x, v.y, r * 0.5);
                    g.addColorStop(0, 'rgba(255,200,50,0.8)');
                    g.addColorStop(1, 'transparent');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(v.x, v.y, r * 0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                }

                else if (v.type === 'speed') {
                    // Radiating speed lines + lightning bolts
                    const bolts = 6;
                    for (let i = 0; i < bolts; i++) {
                        const angle = (Math.PI * 2 / bolts) * i + progress * 2;
                        const r = progress * 50;
                        const alpha = (1 - progress) * 0.9;
                        ctx.globalAlpha = alpha;
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(v.x + Math.cos(angle) * 10, v.y + Math.sin(angle) * 10);
                        ctx.lineTo(v.x + Math.cos(angle) * r, v.y + Math.sin(angle) * r);
                        ctx.stroke();
                    }

                    // ‚ö° emoji pulse
                    if (progress < 0.6) {
                        const scale = 1 + progress * 2;
                        const alpha = 1 - progress / 0.6;
                        ctx.globalAlpha = alpha;
                        ctx.font = `${30 * scale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('‚ö°', v.x, v.y - 20 - progress * 40);
                    }
                    ctx.globalAlpha = 1;
                }
            });

            // ‚îÄ‚îÄ DRAW PLAYERS ‚îÄ‚îÄ
            if (gameState.players) {
                gameState.players.forEach((player: any, sessionId: string) => {
                    const isLocal = sessionId === room.sessionId;
                    const color = getPlayerColor(sessionId, player.color);
                    drawTopDownCharacter(ctx, player, color, isLocal, time);
                });
            }

            // ‚îÄ‚îÄ FLOATING TEXTS ‚îÄ‚îÄ
            floatingTextsRef.current = floatingTextsRef.current.filter(ft => { ft.timer -= dt; ft.y -= 50 * dt; return ft.timer > 0; });
            floatingTextsRef.current.forEach(ft => {
                const alpha = Math.min(1, ft.timer * 2);
                ctx.globalAlpha = alpha;
                ctx.font = 'bold 14px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(ft.text, ft.x, ft.y);
                ctx.fillStyle = ft.color;
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.globalAlpha = 1;
            });

            // ‚îÄ‚îÄ GRASS REMAINING BAR ‚îÄ‚îÄ
            const totalInScene = (gameState.grasses?.length || 0);
            const barW = ARENA_W - 40;
            const barH = 12;
            const barX = 20;
            const barY = ARENA_H - 28;
            const barFill = Math.min(1, totalInScene / TOTAL_GRASS);

            // Bar bg
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.roundRect(barX - 2, barY - 2, barW + 4, barH + 4, 4);
            ctx.fill();

            // Gradient fill
            const barGrad = ctx.createLinearGradient(barX, 0, barX + barW, 0);
            barGrad.addColorStop(0, '#22c55e');
            barGrad.addColorStop(0.5, '#4ade80');
            barGrad.addColorStop(1, '#86efac');
            ctx.fillStyle = barGrad;
            ctx.beginPath();
            ctx.roundRect(barX, barY, barW * barFill, barH, 3);
            ctx.fill();

            // Bar border
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(barX - 2, barY - 2, barW + 4, barH + 4, 4);
            ctx.stroke();

            ctx.restore();

            animationFrameId = requestAnimationFrame(render);
        };

        animationFrameId = requestAnimationFrame(render);
        return () => cancelAnimationFrame(animationFrameId);
    }, [gameState, nightMode, room.sessionId, getPlayerColor]);

    const getScoreboard = () => {
        if (!gameState.players) return [];
        const entries: any[] = [];
        gameState.players.forEach((p: any, id: string) => {
            entries.push({ name: p.displayName, score: p.score, id, color: getPlayerColor(id, p.color) });
        });
        return entries.sort((a, b) => b.score - a.score);
    };

    const timerSeconds = Math.ceil(gameState.matchTimer || 0);
    const timerDanger = timerSeconds <= 10 && timerSeconds > 0;
    const grassRemaining = gameState.grasses?.length || 0;
    const grassCollected = TOTAL_GRASS - grassRemaining;
    const grassPercent = Math.round((grassCollected / TOTAL_GRASS) * 100);

    return (
        <div className={`relative w-full max-w-7xl mx-auto mt-4 flex flex-col items-center ${nightMode ? 'text-white' : ''}`}>
            
            {/* Day/Night Toggle ‚Äî exactly same as home page, fixed top-left */}
            <motion.button
                onClick={() => setNightMode(!nightMode)}
                className={`fixed top-4 left-4 z-50 w-14 h-14 border-4 flex items-center justify-center transition-colors duration-500 cursor-pointer pixel-corners ${nightMode
                    ? 'bg-indigo-600 border-indigo-800 hover:bg-indigo-500'
                    : 'bg-amber-400 border-amber-600 hover:bg-amber-300'
                    }`}
                whileHover={{ scale: 1.1, rotate: 15 }}
                whileTap={{ scale: 0.9 }}
                title={nightMode ? 'Switch to Day' : 'Switch to Night'}
            >
                <AnimatePresence mode="wait">
                    {nightMode ? (
                        <motion.div
                            key="moon"
                            initial={{ rotate: -90, opacity: 0, scale: 0 }}
                            animate={{ rotate: 0, opacity: 1, scale: 1 }}
                            exit={{ rotate: 90, opacity: 0, scale: 0 }}
                            transition={{ duration: 0.3 }}
                        >
                            <Moon size={24} className="text-yellow-200" fill="currentColor" />
                        </motion.div>
                    ) : (
                        <motion.div
                            key="sun"
                            initial={{ rotate: 90, opacity: 0, scale: 0 }}
                            animate={{ rotate: 0, opacity: 1, scale: 1 }}
                            exit={{ rotate: -90, opacity: 0, scale: 0 }}
                            transition={{ duration: 0.3 }}
                        >
                            <Sun size={24} className="text-amber-800" />
                        </motion.div>
                    )}
                </AnimatePresence>
            </motion.button>

            {/* Day/Night label indicator ‚Äî fixed top-left */}
            <motion.div
                className={`fixed top-5 left-20 z-50 font-display text-[10px] uppercase tracking-widest px-3 py-1 border-2 transition-colors duration-500 ${nightMode
                    ? 'bg-indigo-900/80 border-indigo-600 text-indigo-300'
                    : 'bg-amber-100/80 border-amber-500 text-amber-800'
                    }`}
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.3 }}
            >
                {nightMode ? 'üåô Night' : '‚òÄÔ∏è Day'}
            </motion.div>

            {/* ‚îÄ‚îÄ TOP BAR ‚Äî Timer + Event Notification ‚îÄ‚îÄ */}
            <div className="w-full flex justify-between items-start mb-3 px-2 gap-4">
                {/* Timer */}
                <motion.div
                    animate={timerDanger ? { scale: [1, 1.05, 1] } : {}}
                    transition={{ repeat: Infinity, duration: 0.6 }}
                    className={`px-4 py-2 border-4 flex items-center gap-3 font-display shadow-lg
                        ${timerDanger
                            ? 'bg-red-900 border-red-400 text-red-200'
                            : nightMode
                                ? 'bg-slate-900 border-red-500 text-red-300'
                                : 'bg-white border-red-500 text-red-600'}`}
                >
                    <Timer size={20} className={`${timerDanger ? 'animate-spin' : 'animate-pulse'} text-red-400`} />
                    <span className="text-xl tabular-nums">{timerSeconds}s</span>
                </motion.div>

                {/* Event notification */}
                <AnimatePresence>
                    {lastEvent && (
                        <motion.div
                            key={lastEvent}
                            initial={{ opacity: 0, y: -20, scale: 0.9 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: -10, scale: 0.95 }}
                            className={`px-5 py-3 border-4 font-display text-xs uppercase flex items-center gap-2 shadow-xl
                                ${eventIcon === 'bomb' ? 'bg-red-900/90 border-red-400 text-red-200' :
                                    eventIcon === 'rocket' ? 'bg-orange-900/90 border-orange-400 text-orange-200' :
                                        eventIcon === 'speed' ? 'bg-yellow-900/90 border-yellow-400 text-yellow-200' :
                                            nightMode ? 'bg-slate-900 border-yellow-500 text-yellow-300' : 'bg-yellow-50 border-yellow-500 text-yellow-800'}`}
                        >
                            {eventIcon === 'bomb' && <span className="text-lg">üí£</span>}
                            {eventIcon === 'rocket' && <span className="text-lg">üöÄ</span>}
                            {eventIcon === 'speed' && <span className="text-lg">‚ö°</span>}
                            {lastEvent}
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* ‚îÄ‚îÄ MAIN LAYOUT: Arena + Side Panel ‚îÄ‚îÄ */}
            <div className="w-full flex gap-4 items-start px-2">
                {/* ARENA CANVAS */}
                <div className={`relative border-8 shadow-2xl overflow-hidden flex-1
                    ${nightMode ? 'border-indigo-600' : 'border-amber-500'}
                    ${nightMode ? 'shadow-indigo-900/50' : 'shadow-amber-900/30'}`}
                    style={{ imageRendering: 'pixelated' }}>

                    {/* Outer glow */}
                    <div className={`absolute inset-0 pointer-events-none z-10
                        ${nightMode ? 'ring-2 ring-indigo-400/30' : 'ring-2 ring-amber-400/30'}`} />

                    <canvas ref={canvasRef} width={1200} height={900} className="w-full h-auto block" />

                    {/* Countdown */}
                    <AnimatePresence>
                        {gameState.countdown > 0 && (
                            <motion.div
                                initial={{ scale: 2, opacity: 0 }}
                                animate={{ scale: 1, opacity: 1 }}
                                exit={{ scale: 0, opacity: 0 }}
                                className="absolute inset-0 flex items-center justify-center bg-black/50 backdrop-blur-sm z-30"
                            >
                                <motion.div
                                    key={gameState.countdown}
                                    initial={{ scale: 2.5, rotate: -10 }}
                                    animate={{ scale: 1, rotate: 0 }}
                                    className="font-display text-9xl text-white drop-shadow-[0_0_40px_rgba(251,191,36,0.8)]"
                                    style={{ WebkitTextStroke: '4px #000', textShadow: '0 0 40px rgba(251,191,36,0.8)' }}
                                >
                                    {gameState.countdown}
                                </motion.div>
                            </motion.div>
                        )}
                    </AnimatePresence>

                {/* ‚ïê‚ïê‚ïê PREMIUM LOBBY / WAITING ROOM ‚ïê‚ïê‚ïê */}
                {!gameState.matchStarted && gameState.countdown === 0 && (
                    <div className={`absolute inset-0 flex items-center justify-center backdrop-blur-xl z-20 p-8 overflow-y-auto ${nightMode ? 'bg-black/80' : 'bg-amber-50/90'}`}>
                        <motion.div 
                            initial={{ opacity: 0, scale: 0.9 }}
                            animate={{ opacity: 1, scale: 1 }}
                            className="w-full max-w-4xl grid grid-cols-1 lg:grid-cols-2 gap-8"
                        >
                            {/* LEFT SIDE: Player List & Lobby Info */}
                            <div className="space-y-6">
                                <div className="text-left">
                                    <div className="flex items-center gap-3 mb-1">
                                        <div className={`px-2 py-1 rounded-sm ${nightMode ? 'bg-indigo-600' : 'bg-amber-500'}`}>
                                            <span className="font-display text-[10px] text-white uppercase tracking-tighter">Lobby Room</span>
                                        </div>
                                        <span className={`font-display text-sm tabular-nums ${nightMode ? 'text-slate-400' : 'text-amber-700'}`}>ID: {room.id}</span>
                                    </div>
                                    <h2 className={`font-display text-4xl tracking-widest uppercase ${nightMode ? 'text-white' : 'text-amber-900'}`} style={{ textShadow: nightMode ? '4px 4px 0 #4f46e5' : '4px 4px 0 #fbbf24' }}>
                                        Are you Ready?
                                    </h2>
                                    <p className={`font-body text-sm mt-3 ${nightMode ? 'text-slate-400' : 'text-amber-700/80'}`}>
                                        Waiting for all players to mark themselves as ready. 
                                        Game will start automatically once everyone is set.
                                    </p>
                                </div>

                                <div className={`border-4 p-4 space-y-3 ${nightMode ? 'bg-slate-900/50 border-indigo-500/30' : 'bg-amber-50/80 border-amber-400/50'}`}>
                                    <div className={`flex justify-between items-center mb-4 pb-2 border-b ${nightMode ? 'border-white/10' : 'border-amber-300/40'}`}>
                                        <span className={`font-display text-xs ${nightMode ? 'text-indigo-300' : 'text-amber-700'}`}>Players ({gameState.players?.size || 0}/{MAX_PLAYERS})</span>
                                        <span className={`font-display text-[10px] uppercase ${nightMode ? 'text-white/40' : 'text-amber-600/60'}`}>Status</span>
                                    </div>
                                    
                                    {Array.from(gameState.players || []).map(([id, p]: [string, any]) => {
                                        const isLocal = id === room.sessionId;
                                        const isOwner = id === gameState.ownerId;
                                        return (
                                            <motion.div 
                                                key={id}
                                                layout
                                                className={`flex items-center gap-3 p-3 border-2 transition-colors ${
                                                    p.isReady
                                                        ? 'border-green-500/50 bg-green-500/10'
                                                        : nightMode ? 'border-white/5 bg-white/5' : 'border-amber-300/30 bg-amber-100/30'
                                                }`}
                                            >
                                                <div 
                                                    className="w-8 h-8 border-2 border-black/40 flex-shrink-0"
                                                    style={{ backgroundColor: getPlayerColor(id, p.color) }}
                                                />
                                                <div className="flex-1 overflow-hidden">
                                                    <div className="flex items-center gap-2">
                                                        <span className={`font-display text-sm truncate ${isLocal ? 'text-yellow-400' : nightMode ? 'text-white' : 'text-amber-900'}`}>
                                                            {p.displayName} {isLocal && "(You)"}
                                                        </span>
                                                        {isOwner && <Crown size={12} className="text-yellow-500" />}
                                                    </div>
                                                    <span className={`font-body text-[10px] block leading-tight ${nightMode ? 'text-white/40' : 'text-amber-700/60'}`}>
                                                        {isOwner ? "Room Master" : "Challenger"}
                                                    </span>
                                                </div>
                                                
                                                <div className="flex items-center gap-2">
                                                    {p.isReady ? (
                                                        <div className="flex items-center gap-1.5 text-green-400">
                                                            <span className="font-display text-[10px] uppercase">Ready</span>
                                                            <CheckCircle2 size={16} />
                                                        </div>
                                                    ) : (
                                                        <div className={`flex items-center gap-1.5 ${nightMode ? 'text-white/20' : 'text-amber-400/60'}`}>
                                                            <span className="font-display text-[10px] uppercase">Waiting</span>
                                                            <Circle size={16} />
                                                        </div>
                                                    )}
                                                </div>
                                            </motion.div>
                                        );
                                    })}

                                    {/* Empty slots */}
                                    {Array.from({ length: Math.max(0, 2 - (gameState.players?.size || 0)) }).map((_, i) => (
                                        <div key={`empty-${i}`} className={`flex items-center gap-3 p-3 border-2 border-dashed opacity-30 ${nightMode ? 'border-white/10' : 'border-amber-400/30'}`}>
                                            <div className={`w-8 h-8 border-2 border-dashed ${nightMode ? 'bg-white/5 border-white/20' : 'bg-amber-200/20 border-amber-400/30'}`} />
                                            <span className={`font-display text-[10px] uppercase tracking-widest ${nightMode ? 'text-white/40' : 'text-amber-700/50'}`}>Waiting for player...</span>
                                        </div>
                                    ))}
                                </div>

                                <div className="flex gap-4 pt-2">
                                    <PixelButton 
                                        variant={gameState.players?.get(room.sessionId)?.isReady ? "secondary" : "primary"}
                                        className="flex-1 py-4 text-sm"
                                        onClick={() => room.send("ready")}
                                    >
                                        {gameState.players?.get(room.sessionId)?.isReady ? "CANCEL READY" : "I AM READY!"}
                                    </PixelButton>
                                    <PixelButton variant="accent" className="px-6" onClick={onLeave}>EXIT</PixelButton>
                                </div>
                            </div>

                            {/* RIGHT SIDE: Instructions & Game Rules */}
                            <div className={`border-4 p-6 flex flex-col justify-between ${nightMode ? 'bg-indigo-950/20 border-indigo-900/50' : 'bg-amber-50/80 border-amber-400/50'}`}>
                                <div className="space-y-6">
                                    <div className="text-left space-y-4">
                                        <h3 className={`font-display text-xl uppercase tracking-wider flex items-center gap-2 ${nightMode ? 'text-yellow-400' : 'text-amber-700'}`}>
                                            <div className={`w-2 h-6 ${nightMode ? 'bg-yellow-400' : 'bg-amber-500'}`} />
                                            How to Play
                                        </h3>
                                        
                                        <div className="space-y-4">
                                            <div className="flex gap-4 items-start">
                                                <div className={`p-2 border font-display text-xs ${nightMode ? 'bg-slate-800 border-slate-700 text-white' : 'bg-amber-100 border-amber-300 text-amber-800'}`}>MK</div>
                                                <div className="flex-1">
                                                    <p className={`font-display text-[11px] uppercase mb-1 ${nightMode ? 'text-white' : 'text-amber-900'}`}>Movement</p>
                                                    <p className={`font-body text-xs ${nightMode ? 'text-slate-400' : 'text-amber-700'}`}>Use WASD or Arrow Keys to navigate the field and collect grass.</p>
                                                </div>
                                            </div>

                                            <div className="flex gap-4 items-start">
                                                <div className={`p-2 border font-display text-xs ${nightMode ? 'bg-slate-800 border-slate-700 text-white' : 'bg-amber-100 border-amber-300 text-amber-800'}`}>GR</div>
                                                <div className="flex-1">
                                                    <p className={`font-display text-[11px] uppercase mb-1 ${nightMode ? 'text-white' : 'text-amber-900'}`}>Two-Phase Harvesting</p>
                                                    <p className={`font-body text-xs ${nightMode ? 'text-slate-400' : 'text-amber-700'}`}>Touch Big Grass (2pts) to convert it to Small Grass. Wait 0.5s to harvest it again (1pt).</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div className="space-y-3">
                                        <h4 className={`font-display text-[11px] uppercase tracking-widest pb-2 border-b ${nightMode ? 'text-indigo-300 border-white/5' : 'text-amber-600 border-amber-300/40'}`}>Arena Objects</h4>
                                        <div className="grid grid-cols-2 gap-3">
                                            <div className={`p-2 rounded flex items-center gap-2 border ${nightMode ? 'bg-black/20 border-white/5' : 'bg-amber-100/50 border-amber-300/40'}`}>
                                                <span className="text-xl">üí£</span>
                                                <span className={`font-display text-[9px] uppercase ${nightMode ? 'text-red-300' : 'text-red-600'}`}>Bomb Trap</span>
                                            </div>
                                            <div className={`p-2 rounded flex items-center gap-2 border ${nightMode ? 'bg-black/20 border-white/5' : 'bg-amber-100/50 border-amber-300/40'}`}>
                                                <span className="text-xl">üöÄ</span>
                                                <span className={`font-display text-[9px] uppercase ${nightMode ? 'text-orange-300' : 'text-orange-600'}`}>Nuke Rocket</span>
                                            </div>
                                            <div className={`p-2 rounded flex items-center gap-2 border ${nightMode ? 'bg-black/20 border-white/5' : 'bg-amber-100/50 border-amber-300/40'}`}>
                                                <span className="text-xl">‚ö°</span>
                                                <span className={`font-display text-[9px] uppercase ${nightMode ? 'text-blue-300' : 'text-blue-600'}`}>Super Speed</span>
                                            </div>
                                            <div className={`p-2 rounded flex items-center gap-2 border ${nightMode ? 'bg-black/20 border-white/5' : 'bg-amber-100/50 border-amber-300/40'}`}>
                                                <span className="text-xl">üåø</span>
                                                <span className={`font-display text-[9px] uppercase ${nightMode ? 'text-green-300' : 'text-green-600'}`}>Double Grass</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div className={`mt-8 p-4 rounded-sm border ${nightMode ? 'bg-yellow-400/10 border-yellow-400/20' : 'bg-amber-100/60 border-amber-400/40'}`}>
                                    <div className="flex items-center gap-3">
                                        <div className={`animate-pulse w-2 h-2 rounded-full ${nightMode ? 'bg-yellow-400 shadow-[0_0_8px_#facc15]' : 'bg-amber-500 shadow-[0_0_8px_#f59e0b]'}`} />
                                        <p className={`font-body text-[11px] leading-relaxed italic ${nightMode ? 'text-yellow-100/80' : 'text-amber-800'}`}>
                                            "Pro Tip: Use the Rocket only when your opponents are about to clear a large patch!"
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </motion.div>
                    </div>
                )}
                </div>

                {/* ‚îÄ‚îÄ RIGHT SIDE PANEL ‚îÄ‚îÄ */}
                <div className="flex flex-col gap-3" style={{ width: '220px', flexShrink: 0 }}>
                    {/* Grass Counter Card */}
                    <div className={`border-4 font-display shadow-lg overflow-hidden
                        ${nightMode ? 'bg-slate-900/95 border-green-500' : 'bg-white/95 border-green-500'}`}>
                        <div className={`px-3 py-1 text-center font-bold text-[10px] tracking-widest
                            ${nightMode ? 'bg-green-900/50 text-green-300' : 'bg-green-50 text-green-700'}`}>
                            üåø GRASS COLLECTED
                        </div>
                        <div className="px-3 py-3 text-center">
                            <div className={`text-3xl font-display tabular-nums ${nightMode ? 'text-green-300' : 'text-green-600'}`}>
                                {grassCollected}
                                <span className={`text-lg ${nightMode ? 'text-green-500/60' : 'text-green-400'}`}>/{TOTAL_GRASS}</span>
                            </div>
                            {/* Progress bar */}
                            <div className={`mt-2 h-3 border-2 overflow-hidden
                                ${nightMode ? 'bg-slate-800 border-green-700' : 'bg-green-100 border-green-400'}`}>
                                <motion.div
                                    className="h-full"
                                    style={{
                                        width: `${grassPercent}%`,
                                        background: 'linear-gradient(90deg, #22c55e, #4ade80, #86efac)',
                                    }}
                                    initial={{ width: 0 }}
                                    animate={{ width: `${grassPercent}%` }}
                                    transition={{ duration: 0.3 }}
                                />
                            </div>
                            <p className={`mt-1 text-[9px] ${nightMode ? 'text-green-400/60' : 'text-green-500'}`}>
                                {grassPercent}% cleared
                            </p>
                        </div>
                    </div>

                    {/* Scoreboard */}
                    <div className={`border-4 font-display text-xs shadow-lg
                        ${nightMode ? 'bg-slate-900/95 border-indigo-500 text-slate-200' : 'bg-white/95 border-slate-700 text-slate-800'}`}>
                        <div className={`px-3 py-1 text-center font-bold text-[10px] tracking-widest
                            ${nightMode ? 'bg-indigo-900/50 text-indigo-300' : 'bg-slate-100 text-slate-600'}`}>
                            ‚ñ∏ SCORES ‚óÇ
                        </div>
                        <div className="px-3 py-1">
                            {getScoreboard().map((entry, i) => (
                                <div key={entry.id} className={`flex items-center gap-2 py-1.5 ${i === 0 ? '' : `border-t ${nightMode ? 'border-slate-700/50' : 'border-slate-100'}`}`}>
                                    <span className={`text-[9px] w-4 font-bold ${i === 0 ? 'text-yellow-400' : 'opacity-60'}`}>
                                        {i === 0 ? 'üëë' : `${i + 1}.`}
                                    </span>
                                    <div className="w-4 h-4 border-2 border-black/30" style={{ backgroundColor: entry.color }} />
                                    <span className="flex-1 truncate text-[10px]">{entry.name}</span>
                                    <span className="text-green-400 font-bold text-sm">{entry.score}</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Controls hint */}
                    <div className={`border-4 font-display text-[9px] shadow-lg px-3 py-2
                        ${nightMode ? 'bg-slate-900/95 border-slate-600 text-slate-400' : 'bg-white/95 border-slate-300 text-slate-500'}`}>
                        <div className="flex items-center gap-2 mb-1">
                            <span className="text-[10px]">üéÆ</span>
                            <span className="tracking-wider">CONTROLS</span>
                        </div>
                        <p className="opacity-70">WASD / ARROWS ‚Äî MOVE</p>
                    </div>

                    {/* Exit button */}
                    <PixelButton variant="secondary" size="sm" onClick={onLeave}>Exit Arena</PixelButton>
                </div>
            </div>

            {/* ‚îÄ‚îÄ END SCREEN ‚îÄ‚îÄ */}
            <AnimatePresence>
                {showEndScreen && (
                    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-lg">
                        <motion.div
                            initial={{ scale: 0.8, opacity: 0, y: 30 }}
                            animate={{ scale: 1, opacity: 1, y: 0 }}
                            className="w-full max-w-md mx-4"
                        >
                            <PixelCard title="Game Over" nightMode={nightMode}>
                                <div className="text-center p-6 space-y-6">
                                    <motion.div
                                        animate={{ rotate: [0, -10, 10, -5, 5, 0], scale: [1, 1.2, 1] }}
                                        transition={{ duration: 0.8, delay: 0.3 }}
                                    >
                                        <Trophy size={80} className="mx-auto text-yellow-500 drop-shadow-lg" />
                                    </motion.div>
                                    <motion.h2
                                        initial={{ y: 10, opacity: 0 }}
                                        animate={{ y: 0, opacity: 1 }}
                                        transition={{ delay: 0.5 }}
                                        className="font-display text-3xl"
                                    >
                                        {gameState.winnerId
                                            ? (gameState.players?.get(gameState.winnerId)?.displayName || "Winner") + " WINS!"
                                            : "IT'S A DRAW!"}
                                    </motion.h2>
                                    <div className="space-y-2 text-sm">
                                        {getScoreboard().map((entry, i) => (
                                            <motion.div
                                                key={entry.id}
                                                initial={{ x: -20, opacity: 0 }}
                                                animate={{ x: 0, opacity: 1 }}
                                                transition={{ delay: 0.6 + i * 0.1 }}
                                                className="flex items-center gap-3 px-4 py-2 bg-black/20 rounded"
                                            >
                                                <span className="font-display text-xs opacity-60">#{i + 1}</span>
                                                <div className="w-4 h-4 border border-black/30 rounded-sm" style={{ backgroundColor: entry.color }} />
                                                <span className="flex-1 font-display text-xs">{entry.name}</span>
                                                <span className="font-display text-xs text-green-400">{entry.score} üåø</span>
                                            </motion.div>
                                        ))}
                                    </div>
                                    <PixelButton variant="primary" className="w-full" onClick={onLeave}>
                                        Main Menu
                                    </PixelButton>
                                </div>
                            </PixelCard>
                        </motion.div>
                    </div>
                )}
            </AnimatePresence>
        </div>
    );
};




Authscreen.tsx:-import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'motion/react';
import { PixelButton } from './PixelButton';
import { PixelCard } from './PixelCard';
import {
    User, Mail, Lock, Eye, EyeOff, UserPlus, LogIn, Ghost, Swords,
    Shield, ChevronRight, Sparkles, AlertTriangle, CheckCircle, X,
} from 'lucide-react';

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Types
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

export interface UserProfile {
    id: string;
    username: string;
    email?: string;
    isGuest: boolean;
    avatarColor: string;
    level: number;
    xp: number;
    wins: number;
    matches: number;
    createdAt: string;
}

interface AuthScreenProps {
    nightMode: boolean;
    onAuth: (user: UserProfile) => void;
    onClose: () => void;
    initialTab?: 'signin' | 'signup';
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Helper: localStorage user DB (simulated)
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

const USERS_KEY = 'chaos_arena_users';
const SESSION_KEY = 'chaos_arena_session';

function getStoredUsers(): Record<string, { username: string; email: string; password: string; profile: UserProfile }> {
    try {
        return JSON.parse(localStorage.getItem(USERS_KEY) || '{}');
    } catch { return {}; }
}

function saveStoredUsers(users: Record<string, any>) {
    localStorage.setItem(USERS_KEY, JSON.stringify(users));
}

function generateId(): string {
    return Math.random().toString(36).substring(2, 10) + Date.now().toString(36);
}

const AVATAR_COLORS = [
    '#ef4444', '#3b82f6', '#22c55e', '#eab308',
    '#a855f7', '#f97316', '#ec4899', '#06b6d4',
];

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Mini Stickman Avatar for preview
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

const MiniStickman: React.FC<{ color: string; size?: number; animate?: boolean }> = ({
    color, size = 48, animate = false,
}) => {
    const s = (v: number) => `${(v / 60) * size}px`;
    return (
        <motion.div
            className="relative"
            style={{ width: `${size}px`, height: `${(90 / 60) * size}px`, imageRendering: 'pixelated' }}
            animate={animate ? { y: [0, -4, 0] } : {}}
            transition={animate ? { duration: 1.2, repeat: Infinity, ease: 'easeInOut' } : {}}
        >
            {/* Head */}
            <div className="absolute left-1/2 -translate-x-1/2" style={{
                top: 0, width: s(22), height: s(22), backgroundColor: color,
                border: `${s(3)} solid #111`,
                boxShadow: `inset ${s(-3)} ${s(-3)} 0 0 rgba(0,0,0,0.25), inset ${s(2)} ${s(2)} 0 0 rgba(255,255,255,0.15)`,
            }}>
                {/* Eyes */}
                <div className="absolute" style={{
                    top: s(6), left: s(3), width: s(4), height: s(4), backgroundColor: '#fff',
                    boxShadow: `${s(7)} 0 0 0 #fff`,
                }} />
                {/* Mouth */}
                <div className="absolute" style={{
                    bottom: s(3), left: s(5), width: s(8), height: s(2), backgroundColor: '#111',
                }} />
            </div>
            {/* Body */}
            <div className="absolute left-1/2 -translate-x-1/2" style={{
                top: s(24), width: s(16), height: s(22), backgroundColor: color,
                border: `${s(3)} solid #111`,
            }}>
                {/* Belt */}
                <div style={{
                    position: 'absolute', bottom: 0, left: 0, right: 0,
                    height: s(4), backgroundColor: 'rgba(0,0,0,0.4)',
                }} />
                <div style={{
                    position: 'absolute', bottom: s(0.5), left: '50%', transform: 'translateX(-50%)',
                    width: s(4), height: s(3), backgroundColor: '#fbbf24',
                    border: `${s(0.5)} solid #92400e`,
                }} />
            </div>
            {/* Arms */}
            <div className="absolute" style={{
                top: s(24), left: s(4), width: s(8), height: s(16), backgroundColor: color,
                border: `${s(2)} solid #111`,
            }} />
            <div className="absolute" style={{
                top: s(24), right: s(4), width: s(8), height: s(16), backgroundColor: color,
                border: `${s(2)} solid #111`,
            }} />
            {/* Legs */}
            <div className="absolute" style={{
                top: s(46), left: s(14), width: s(10), height: s(20), backgroundColor: color,
                border: `${s(2)} solid #111`, filter: 'brightness(0.8)',
            }} />
            <div className="absolute" style={{
                top: s(46), right: s(14), width: s(10), height: s(20), backgroundColor: color,
                border: `${s(2)} solid #111`, filter: 'brightness(0.8)',
            }} />
            {/* Boots */}
            <div className="absolute" style={{
                top: s(64), left: s(10), width: s(14), height: s(7), backgroundColor: '#1c1917',
                border: `${s(1.5)} solid #000`,
            }} />
            <div className="absolute" style={{
                top: s(64), right: s(10), width: s(14), height: s(7), backgroundColor: '#1c1917',
                border: `${s(1.5)} solid #000`,
            }} />
        </motion.div>
    );
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Pixel Input Component
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

const PixelInput: React.FC<{
    icon: React.ReactNode;
    type: string;
    placeholder: string;
    value: string;
    onChange: (v: string) => void;
    nightMode: boolean;
    error?: string;
    showToggle?: boolean;
}> = ({ icon, type, placeholder, value, onChange, nightMode, error, showToggle }) => {
    const [showPassword, setShowPassword] = useState(false);
    const actualType = showToggle ? (showPassword ? 'text' : 'password') : type;

    return (
        <div className="space-y-1">
            <div className={`flex items-center gap-3 px-4 py-3 border-4 transition-all duration-300 ${error
                ? 'border-red-500 bg-red-500/10'
                : nightMode
                    ? 'border-slate-600 bg-slate-700/50 focus-within:border-indigo-400 focus-within:bg-slate-700'
                    : 'border-slate-300 bg-white focus-within:border-indigo-500 focus-within:bg-indigo-50/30'
                }`}
            >
                <div className={`${nightMode ? 'text-slate-400' : 'text-slate-500'}`}>
                    {icon}
                </div>
                <input
                    type={actualType}
                    placeholder={placeholder}
                    value={value}
                    onChange={(e) => onChange(e.target.value)}
                    className={`flex-1 bg-transparent outline-none font-body text-xl placeholder:opacity-40 ${nightMode ? 'text-slate-100 placeholder:text-slate-500' : 'text-slate-800 placeholder:text-slate-400'
                        }`}
                />
                {showToggle && (
                    <button
                        type="button"
                        onClick={() => setShowPassword(!showPassword)}
                        className={`${nightMode ? 'text-slate-500 hover:text-slate-300' : 'text-slate-400 hover:text-slate-600'} transition-colors`}
                    >
                        {showPassword ? <EyeOff size={18} /> : <Eye size={18} />}
                    </button>
                )}
            </div>
            {error && (
                <motion.p
                    initial={{ opacity: 0, y: -4 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="text-red-400 font-body text-sm flex items-center gap-1 pl-1"
                >
                    <AlertTriangle size={12} /> {error}
                </motion.p>
            )}
        </div>
    );
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Floating pixel particles background
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

const AuthParticles: React.FC = () => {
    const particles = Array.from({ length: 20 }, (_, i) => ({
        id: i,
        x: Math.random() * 100,
        delay: Math.random() * 4,
        duration: 4 + Math.random() * 6,
        size: 3 + Math.floor(Math.random() * 2) * 2,
        color: AVATAR_COLORS[Math.floor(Math.random() * AVATAR_COLORS.length)],
    }));
    return (
        <div className="absolute inset-0 pointer-events-none overflow-hidden z-0">
            {particles.map((p) => (
                <motion.div key={p.id} className="absolute"
                    style={{
                        left: `${p.x}%`, bottom: '-10px',
                        width: `${p.size}px`, height: `${p.size}px`,
                        backgroundColor: p.color, imageRendering: 'pixelated',
                        opacity: 0.3,
                    }}
                    animate={{ y: [0, -600], opacity: [0, 0.4, 0.4, 0] }}
                    transition={{ delay: p.delay, duration: p.duration, repeat: Infinity, ease: 'linear' }}
                />
            ))}
        </div>
    );
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Auth Gate Prompt (the "not logged in" nudge)
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

export const AuthGatePrompt: React.FC<{
    nightMode: boolean;
    onSignIn: () => void;
    onSignUp: () => void;
    onGuest: () => void;
    onClose: () => void;
}> = ({ nightMode, onSignIn, onSignUp, onGuest, onClose }) => {
    return (
        <motion.div
            className="fixed inset-0 z-[70] flex items-center justify-center bg-black/70 backdrop-blur-md"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
        >
            <motion.div
                initial={{ scale: 0.7, opacity: 0, y: 40 }}
                animate={{ scale: 1, opacity: 1, y: 0 }}
                exit={{ scale: 0.8, opacity: 0 }}
                transition={{ type: 'spring', bounce: 0.3 }}
                className="w-full max-w-sm mx-4"
            >
                <PixelCard nightMode={nightMode} title="Hold Up!">
                    <div className="text-center space-y-5 pt-4">
                        {/* Shield icon */}
                        <motion.div
                            animate={{ rotate: [0, -5, 5, -5, 0], scale: [1, 1.05, 1] }}
                            transition={{ duration: 2, repeat: Infinity }}
                        >
                            <Shield size={56} className={`mx-auto ${nightMode ? 'text-indigo-400' : 'text-indigo-500'}`} />
                        </motion.div>

                        <div>
                            <h2 className={`font-display text-sm uppercase tracking-wider mb-2 ${nightMode ? 'text-slate-200' : 'text-slate-800'
                                }`}>
                                Authentication Required
                            </h2>
                            <p className={`font-body text-lg ${nightMode ? 'text-slate-400' : 'text-slate-600'}`}>
                                Create an account or sign in to join the battle.<br />
                                Or hop in as a guest ‚Äî your call!
                            </p>
                        </div>

                        <div className="space-y-3">
                            <PixelButton variant="primary" size="md" className="w-full" onClick={onSignUp}>
                                <UserPlus size={16} className="inline mr-2" /> Sign Up
                            </PixelButton>
                            <PixelButton variant="secondary" size="md" className="w-full" onClick={onSignIn}>
                                <LogIn size={16} className="inline mr-2" /> Sign In
                            </PixelButton>
                            <div className="relative py-2">
                                <div className={`absolute inset-0 flex items-center ${nightMode ? 'opacity-30' : 'opacity-20'}`}>
                                    <div className="w-full border-t-2 border-dashed border-slate-400" />
                                </div>
                                <div className={`relative flex justify-center ${nightMode ? 'bg-slate-800' : 'bg-white'}`}>
                                    <span className={`px-3 font-display text-[8px] uppercase ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                                        or
                                    </span>
                                </div>
                            </div>
                            <PixelButton variant="accent" size="sm" className="w-full" onClick={onGuest}>
                                <Ghost size={16} className="inline mr-2" /> Play as Guest
                            </PixelButton>
                        </div>

                        <button
                            onClick={onClose}
                            className={`font-body text-base underline mt-2 ${nightMode ? 'text-slate-500 hover:text-slate-300' : 'text-slate-400 hover:text-slate-600'
                                } transition-colors`}
                        >
                            Back to Menu
                        </button>
                    </div>
                </PixelCard>
            </motion.div>
        </motion.div>
    );
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Main Auth Screen
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

export const AuthScreen: React.FC<AuthScreenProps> = ({ nightMode, onAuth, onClose, initialTab = 'signin' }) => {
    const [tab, setTab] = useState<'signin' | 'signup'>(initialTab);
    const [selectedColor, setSelectedColor] = useState(AVATAR_COLORS[Math.floor(Math.random() * AVATAR_COLORS.length)]);

    // Sign In state
    const [siUsername, setSiUsername] = useState('');
    const [siPassword, setSiPassword] = useState('');
    const [siErrors, setSiErrors] = useState<Record<string, string>>({});

    // Sign Up state
    const [suUsername, setSuUsername] = useState('');
    const [suEmail, setSuEmail] = useState('');
    const [suPassword, setSuPassword] = useState('');
    const [suConfirm, setSuConfirm] = useState('');
    const [suErrors, setSuErrors] = useState<Record<string, string>>({});

    const [isLoading, setIsLoading] = useState(false);
    const [successMsg, setSuccessMsg] = useState('');

    /* ‚îÄ‚îÄ Sign In handler ‚îÄ‚îÄ */
    const handleSignIn = async () => {
        const errs: Record<string, string> = {};
        if (!siUsername.trim()) errs.username = 'Username is required';
        if (!siPassword) errs.password = 'Password is required';
        if (Object.keys(errs).length) { setSiErrors(errs); return; }

        setIsLoading(true);
        setSiErrors({});

        // Simulate network delay
        await new Promise(r => setTimeout(r, 800));

        const users = getStoredUsers();
        const userEntry = Object.values(users).find(
            u => u.username.toLowerCase() === siUsername.trim().toLowerCase()
        );

        if (!userEntry) {
            setSiErrors({ username: 'No account found with that username' });
            setIsLoading(false);
            return;
        }

        if (userEntry.password !== siPassword) {
            setSiErrors({ password: 'Incorrect password' });
            setIsLoading(false);
            return;
        }

        // Success! ‚Äî sync to app's main keys too
        localStorage.setItem(SESSION_KEY, JSON.stringify(userEntry.profile));
        localStorage.setItem('playerId', userEntry.profile.id);
        localStorage.setItem('displayName', userEntry.profile.username);
        localStorage.setItem('playerColor', userEntry.profile.avatarColor);
        setSuccessMsg('Welcome back, warrior!');
        setTimeout(() => onAuth(userEntry.profile), 1200);
    };

    /* ‚îÄ‚îÄ Sign Up handler ‚îÄ‚îÄ */
    const handleSignUp = async () => {
        const errs: Record<string, string> = {};
        if (!suUsername.trim()) errs.username = 'Pick a warrior name';
        else if (suUsername.trim().length < 3) errs.username = 'At least 3 characters';
        else if (suUsername.trim().length > 16) errs.username = 'Max 16 characters';

        if (!suEmail.trim()) errs.email = 'Email is required';
        else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(suEmail)) errs.email = 'Invalid email format';

        if (!suPassword) errs.password = 'Password is required';
        else if (suPassword.length < 4) errs.password = 'At least 4 characters';

        if (suPassword !== suConfirm) errs.confirm = 'Passwords don\'t match';

        if (Object.keys(errs).length) { setSuErrors(errs); return; }

        setIsLoading(true);
        setSuErrors({});

        await new Promise(r => setTimeout(r, 1000));

        const users = getStoredUsers();
        const existing = Object.values(users).find(
            u => u.username.toLowerCase() === suUsername.trim().toLowerCase()
        );
        if (existing) {
            setSuErrors({ username: 'That name is already taken!' });
            setIsLoading(false);
            return;
        }

        const emailUsed = Object.values(users).find(
            u => u.email.toLowerCase() === suEmail.trim().toLowerCase()
        );
        if (emailUsed) {
            setSuErrors({ email: 'Email already registered' });
            setIsLoading(false);
            return;
        }

        // Create user
        const profile: UserProfile = {
            id: generateId(),
            username: suUsername.trim(),
            email: suEmail.trim(),
            isGuest: false,
            avatarColor: selectedColor,
            level: 1,
            xp: 0,
            wins: 0,
            matches: 0,
            createdAt: new Date().toISOString(),
        };

        users[profile.id] = {
            username: suUsername.trim(),
            email: suEmail.trim(),
            password: suPassword,
            profile,
        };
        saveStoredUsers(users);
        localStorage.setItem(SESSION_KEY, JSON.stringify(profile));
        localStorage.setItem('playerId', profile.id);
        localStorage.setItem('displayName', profile.username);
        localStorage.setItem('playerColor', profile.avatarColor);

        setSuccessMsg('Account created ‚Äî ready to brawl!');
        setTimeout(() => onAuth(profile), 1200);
    };

    /* ‚îÄ‚îÄ Guest handler ‚îÄ‚îÄ */
    const handleGuest = () => {
        setIsLoading(true);
        setTimeout(() => {
            const guestName = `Guest_${Math.floor(Math.random() * 9000 + 1000)}`;
            // Reuse existing playerId if present
            const existingId = localStorage.getItem('playerId');
            const profile: UserProfile = {
                id: existingId || generateId(),
                username: guestName,
                isGuest: true,
                avatarColor: AVATAR_COLORS[Math.floor(Math.random() * AVATAR_COLORS.length)],
                level: 1,
                xp: 0,
                wins: 0,
                matches: 0,
                createdAt: new Date().toISOString(),
            };
            localStorage.setItem(SESSION_KEY, JSON.stringify(profile));
            localStorage.setItem('playerId', profile.id);
            localStorage.setItem('displayName', profile.username);
            localStorage.setItem('playerColor', profile.avatarColor);
            setSuccessMsg(`Welcome, ${guestName}!`);
            setTimeout(() => onAuth(profile), 800);
        }, 600);
    };

    return (
        <motion.div
            className="fixed inset-0 z-[80] flex items-center justify-center"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
        >
            {/* Backdrop */}
            <div className="absolute inset-0 bg-black/80 backdrop-blur-lg" onClick={onClose} />

            <AuthParticles />

            {/* Main card */}
            <motion.div
                initial={{ scale: 0.8, opacity: 0, y: 60, rotateX: 10 }}
                animate={{ scale: 1, opacity: 1, y: 0, rotateX: 0 }}
                exit={{ scale: 0.9, opacity: 0, y: -20 }}
                transition={{ type: 'spring', bounce: 0.25, duration: 0.6 }}
                className="relative z-10 w-full max-w-lg mx-4"
            >
                {/* Close button */}
                <motion.button
                    whileHover={{ scale: 1.2, rotate: 90 }}
                    whileTap={{ scale: 0.8 }}
                    onClick={onClose}
                    className={`absolute -top-3 -right-3 z-30 w-10 h-10 border-4 flex items-center justify-center cursor-pointer ${nightMode
                        ? 'bg-slate-700 border-slate-500 text-slate-300 hover:bg-red-600 hover:border-red-500 hover:text-white'
                        : 'bg-white border-slate-400 text-slate-600 hover:bg-red-500 hover:border-red-600 hover:text-white'
                        } transition-colors`}
                >
                    <X size={18} />
                </motion.button>

                <div className={`border-4 shadow-[8px_8px_0_0_rgba(0,0,0,0.3)] overflow-hidden transition-colors duration-700 ${nightMode ? 'bg-slate-800 border-slate-600' : 'bg-white border-slate-800'
                    }`}
                >
                    {/* ‚ïê‚ïê‚ïê HEADER WITH STICKMAN ‚ïê‚ïê‚ïê */}
                    <div className={`relative px-6 pt-6 pb-4 ${nightMode
                        ? 'bg-gradient-to-br from-indigo-900/60 via-slate-800 to-purple-900/40'
                        : 'bg-gradient-to-br from-yellow-100 via-white to-indigo-50'
                        }`}
                    >
                        <div className="flex items-center justify-between">
                            <div>
                                <motion.h1
                                    className={`font-display text-xl uppercase tracking-tighter ${nightMode ? 'text-indigo-300' : 'text-indigo-600'}`}
                                    style={{
                                        textShadow: nightMode
                                            ? '3px 3px 0 #000, -1px -1px 0 #6366f1'
                                            : '2px 2px 0 rgba(0,0,0,0.15)',
                                    }}
                                    initial={{ x: -20, opacity: 0 }}
                                    animate={{ x: 0, opacity: 1 }}
                                    transition={{ delay: 0.15 }}
                                >
                                    {tab === 'signin' ? 'Welcome Back' : 'Join Arena'}
                                </motion.h1>
                                <motion.p
                                    className={`font-body text-lg mt-1 ${nightMode ? 'text-slate-400' : 'text-slate-500'}`}
                                    initial={{ x: -20, opacity: 0 }}
                                    animate={{ x: 0, opacity: 1 }}
                                    transition={{ delay: 0.25 }}
                                >
                                    {tab === 'signin' ? 'Enter your credentials to continue' : 'Create your warrior profile'}
                                </motion.p>
                            </div>

                            <motion.div
                                initial={{ scale: 0, rotate: -30 }}
                                animate={{ scale: 1, rotate: 0 }}
                                transition={{ type: 'spring', bounce: 0.5, delay: 0.3 }}
                            >
                                <MiniStickman
                                    color={tab === 'signup' ? selectedColor : (nightMode ? '#818cf8' : '#6366f1')}
                                    size={50}
                                    animate
                                />
                            </motion.div>
                        </div>

                        {/* Tabs */}
                        <div className="flex mt-4 gap-0">
                            {(['signin', 'signup'] as const).map((t) => (
                                <motion.button
                                    key={t}
                                    onClick={() => { setTab(t); setSiErrors({}); setSuErrors({}); setSuccessMsg(''); }}
                                    className={`flex-1 py-2.5 font-display text-[10px] uppercase tracking-widest border-b-4 transition-all duration-300 cursor-pointer ${tab === t
                                        ? nightMode
                                            ? 'bg-indigo-500/20 border-indigo-400 text-indigo-300'
                                            : 'bg-indigo-50 border-indigo-500 text-indigo-700'
                                        : nightMode
                                            ? 'bg-transparent border-slate-700 text-slate-500 hover:text-slate-400 hover:border-slate-600'
                                            : 'bg-transparent border-slate-200 text-slate-400 hover:text-slate-500 hover:border-slate-300'
                                        }`}
                                    whileTap={{ scale: 0.97 }}
                                >
                                    {t === 'signin' ? (
                                        <><LogIn size={14} className="inline mr-1.5 -mt-0.5" /> Sign In</>
                                    ) : (
                                        <><UserPlus size={14} className="inline mr-1.5 -mt-0.5" /> Sign Up</>
                                    )}
                                </motion.button>
                            ))}
                        </div>
                    </div>

                    {/* ‚ïê‚ïê‚ïê FORM BODY ‚ïê‚ïê‚ïê */}
                    <div className="px-6 py-5 space-y-4">
                        {/* Success message overlay */}
                        <AnimatePresence>
                            {successMsg && (
                                <motion.div
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    className={`text-center py-6 space-y-3`}
                                >
                                    <motion.div
                                        animate={{ scale: [1, 1.2, 1], rotate: [0, 10, -10, 0] }}
                                        transition={{ duration: 0.6 }}
                                    >
                                        <CheckCircle size={56} className="mx-auto text-green-400" />
                                    </motion.div>
                                    <p className={`font-display text-sm uppercase ${nightMode ? 'text-green-300' : 'text-green-600'}`}>
                                        {successMsg}
                                    </p>
                                    <motion.div
                                        className="flex justify-center gap-1 mt-2"
                                        animate={{ opacity: [0.4, 1, 0.4] }}
                                        transition={{ duration: 1.2, repeat: Infinity }}
                                    >
                                        {[0, 1, 2].map(i => (
                                            <div key={i} className="w-2 h-2 bg-green-400" style={{ imageRendering: 'pixelated' }} />
                                        ))}
                                    </motion.div>
                                </motion.div>
                            )}
                        </AnimatePresence>

                        {/* Sign In Form */}
                        {!successMsg && tab === 'signin' && (
                            <motion.div
                                key="signin"
                                initial={{ opacity: 0, x: -20 }}
                                animate={{ opacity: 1, x: 0 }}
                                exit={{ opacity: 0, x: 20 }}
                                className="space-y-4"
                            >
                                <PixelInput
                                    icon={<User size={18} />}
                                    type="text"
                                    placeholder="Username"
                                    value={siUsername}
                                    onChange={setSiUsername}
                                    nightMode={nightMode}
                                    error={siErrors.username}
                                />
                                <PixelInput
                                    icon={<Lock size={18} />}
                                    type="password"
                                    placeholder="Password"
                                    value={siPassword}
                                    onChange={setSiPassword}
                                    nightMode={nightMode}
                                    error={siErrors.password}
                                    showToggle
                                />

                                <PixelButton
                                    variant="primary"
                                    size="lg"
                                    className="w-full text-sm"
                                    onClick={handleSignIn}
                                    disabled={isLoading}
                                >
                                    {isLoading ? (
                                        <motion.span
                                            animate={{ opacity: [1, 0.5, 1] }}
                                            transition={{ duration: 0.8, repeat: Infinity }}
                                        >
                                            Authenticating...
                                        </motion.span>
                                    ) : (
                                        <>
                                            <LogIn size={16} className="inline mr-2" />
                                            Enter Arena
                                        </>
                                    )}
                                </PixelButton>

                                <p className={`text-center font-body text-base ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                                    Don't have an account?{' '}
                                    <button
                                        onClick={() => { setTab('signup'); setSiErrors({}); }}
                                        className={`underline font-bold ${nightMode ? 'text-indigo-400 hover:text-indigo-300' : 'text-indigo-600 hover:text-indigo-500'} transition-colors cursor-pointer`}
                                    >
                                        Sign Up
                                    </button>
                                </p>
                            </motion.div>
                        )}

                        {/* Sign Up Form */}
                        {!successMsg && tab === 'signup' && (
                            <motion.div
                                key="signup"
                                initial={{ opacity: 0, x: 20 }}
                                animate={{ opacity: 1, x: 0 }}
                                exit={{ opacity: 0, x: -20 }}
                                className="space-y-4"
                            >
                                <PixelInput
                                    icon={<User size={18} />}
                                    type="text"
                                    placeholder="Warrior name"
                                    value={suUsername}
                                    onChange={setSuUsername}
                                    nightMode={nightMode}
                                    error={suErrors.username}
                                />
                                <PixelInput
                                    icon={<Mail size={18} />}
                                    type="email"
                                    placeholder="Email address"
                                    value={suEmail}
                                    onChange={setSuEmail}
                                    nightMode={nightMode}
                                    error={suErrors.email}
                                />
                                <PixelInput
                                    icon={<Lock size={18} />}
                                    type="password"
                                    placeholder="Password"
                                    value={suPassword}
                                    onChange={setSuPassword}
                                    nightMode={nightMode}
                                    error={suErrors.password}
                                    showToggle
                                />
                                <PixelInput
                                    icon={<Lock size={18} />}
                                    type="password"
                                    placeholder="Confirm password"
                                    value={suConfirm}
                                    onChange={setSuConfirm}
                                    nightMode={nightMode}
                                    error={suErrors.confirm}
                                    showToggle
                                />

                                {/* Avatar Color Picker */}
                                <div>
                                    <p className={`font-display text-[8px] uppercase tracking-widest mb-2 ${nightMode ? 'text-slate-400' : 'text-slate-500'
                                        }`}>
                                        <Sparkles size={12} className="inline mr-1" />
                                        Choose Avatar Color
                                    </p>
                                    <div className="flex gap-2 flex-wrap">
                                        {AVATAR_COLORS.map((c) => (
                                            <motion.button
                                                key={c}
                                                onClick={() => setSelectedColor(c)}
                                                whileHover={{ scale: 1.2 }}
                                                whileTap={{ scale: 0.8 }}
                                                className={`w-8 h-8 border-3 cursor-pointer transition-all ${selectedColor === c
                                                    ? 'border-white shadow-[0_0_12px_rgba(255,255,255,0.5)] scale-110'
                                                    : nightMode
                                                        ? 'border-slate-600 hover:border-slate-400'
                                                        : 'border-slate-300 hover:border-slate-500'
                                                    }`}
                                                style={{ backgroundColor: c }}
                                            >
                                                {selectedColor === c && (
                                                    <motion.div
                                                        initial={{ scale: 0 }}
                                                        animate={{ scale: 1 }}
                                                        className="w-full h-full flex items-center justify-center"
                                                    >
                                                        <div className="w-2 h-2 bg-white" />
                                                    </motion.div>
                                                )}
                                            </motion.button>
                                        ))}
                                    </div>
                                </div>

                                <PixelButton
                                    variant="primary"
                                    size="lg"
                                    className="w-full text-sm"
                                    onClick={handleSignUp}
                                    disabled={isLoading}
                                >
                                    {isLoading ? (
                                        <motion.span
                                            animate={{ opacity: [1, 0.5, 1] }}
                                            transition={{ duration: 0.8, repeat: Infinity }}
                                        >
                                            Creating Warrior...
                                        </motion.span>
                                    ) : (
                                        <>
                                            <Swords size={16} className="inline mr-2" />
                                            Create Account
                                        </>
                                    )}
                                </PixelButton>

                                <p className={`text-center font-body text-base ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                                    Already have an account?{' '}
                                    <button
                                        onClick={() => { setTab('signin'); setSuErrors({}); }}
                                        className={`underline font-bold ${nightMode ? 'text-indigo-400 hover:text-indigo-300' : 'text-indigo-600 hover:text-indigo-500'} transition-colors cursor-pointer`}
                                    >
                                        Sign In
                                    </button>
                                </p>
                            </motion.div>
                        )}

                        {/* ‚îÄ‚îÄ Guest divider + button ‚îÄ‚îÄ */}
                        {!successMsg && (
                            <>
                                <div className="relative py-1">
                                    <div className={`absolute inset-0 flex items-center ${nightMode ? 'opacity-30' : 'opacity-20'}`}>
                                        <div className="w-full border-t-2 border-dashed border-slate-400" />
                                    </div>
                                    <div className={`relative flex justify-center ${nightMode ? 'bg-slate-800' : 'bg-white'}`}>
                                        <span className={`px-4 font-display text-[8px] uppercase tracking-widest ${nightMode ? 'text-slate-600' : 'text-slate-400'}`}>
                                            or skip for now
                                        </span>
                                    </div>
                                </div>

                                <PixelButton
                                    variant="accent"
                                    size="md"
                                    className="w-full text-xs"
                                    onClick={handleGuest}
                                    disabled={isLoading}
                                >
                                    <Ghost size={16} className="inline mr-2" />
                                    Play as Guest
                                </PixelButton>
                            </>
                        )}
                    </div>

                    {/* ‚ïê‚ïê‚ïê FOOTER ‚ïê‚ïê‚ïê */}
                    <div className={`px-6 py-3 text-center font-body text-sm border-t-2 ${nightMode
                        ? 'border-slate-700 text-slate-600 bg-slate-800/50'
                        : 'border-slate-100 text-slate-400 bg-slate-50'
                        }`}>
                        üîí Your data is stored locally on this device
                    </div>
                </div>
            </motion.div>
        </motion.div>
    );
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Player Profile Badge (shown in top-right of main menu)
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

export const PlayerProfileBadge: React.FC<{
    user: UserProfile;
    nightMode: boolean;
    onLogout: () => void;
    onEditProfile?: () => void;
}> = ({ user, nightMode, onLogout, onEditProfile }) => {
    const [showMenu, setShowMenu] = useState(false);

    // XP progress calc
    const xpForNextLevel = user.level * 100;
    const xpProgress = (user.xp / xpForNextLevel) * 100;

    return (
        <div className="fixed top-4 right-4 z-50">
            <motion.div
                initial={{ x: 40, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.4, type: 'spring' }}
            >
                <motion.button
                    onClick={() => setShowMenu(!showMenu)}
                    whileHover={{ scale: 1.03 }}
                    whileTap={{ scale: 0.97 }}
                    className={`flex items-center gap-3 px-4 py-2 border-4 cursor-pointer transition-colors duration-500 ${nightMode
                        ? 'bg-slate-800/90 border-indigo-600 hover:border-indigo-400'
                        : 'bg-white/90 border-slate-700 hover:border-indigo-500'
                        }`}
                >
                    {/* Mini avatar */}
                    <div
                        className="w-8 h-8 border-2 border-black/30 flex items-center justify-center"
                        style={{ backgroundColor: user.avatarColor }}
                    >
                        <div className="w-2 h-2 bg-white" />
                    </div>

                    <div className="text-left">
                        <p className={`font-display text-[9px] uppercase tracking-wide ${nightMode ? 'text-indigo-300' : 'text-slate-800'
                            }`}>
                            {user.username}
                        </p>
                        <p className={`font-body text-xs ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                            {user.isGuest ? 'üëª Guest' : `‚öîÔ∏è Lv.${user.level}`}
                        </p>
                    </div>

                    <ChevronRight
                        size={14}
                        className={`transition-transform duration-200 ${showMenu ? 'rotate-90' : ''} ${nightMode ? 'text-slate-500' : 'text-slate-400'
                            }`}
                    />
                </motion.button>

                {/* Dropdown menu */}
                <AnimatePresence>
                    {showMenu && (
                        <motion.div
                            initial={{ opacity: 0, y: -8, scaleY: 0.8 }}
                            animate={{ opacity: 1, y: 4, scaleY: 1 }}
                            exit={{ opacity: 0, y: -8, scaleY: 0.8 }}
                            transition={{ duration: 0.2 }}
                            className={`absolute right-0 top-full mt-1 w-64 border-4 shadow-[6px_6px_0_0_rgba(0,0,0,0.2)] ${nightMode
                                ? 'bg-slate-800 border-slate-600'
                                : 'bg-white border-slate-700'
                                }`}
                            style={{ transformOrigin: 'top right' }}
                        >
                            {/* Profile header */}
                            <div className={`p-4 border-b-2 ${nightMode ? 'border-slate-700' : 'border-slate-100'}`}>
                                <div className="flex items-center gap-3">
                                    <div
                                        className="w-12 h-12 border-3 border-black/30 flex items-center justify-center"
                                        style={{ backgroundColor: user.avatarColor }}
                                    >
                                        <MiniStickman color={user.avatarColor} size={30} />
                                    </div>
                                    <div>
                                        <p className={`font-display text-xs uppercase ${nightMode ? 'text-slate-200' : 'text-slate-800'}`}>
                                            {user.username}
                                        </p>
                                        <p className={`font-body text-sm ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                                            {user.isGuest ? 'Guest Account' : (user.email || 'Registered')}
                                        </p>
                                    </div>
                                </div>

                                {/* XP bar */}
                                {!user.isGuest && (
                                    <div className="mt-3">
                                        <div className="flex justify-between mb-1">
                                            <span className={`font-display text-[7px] uppercase ${nightMode ? 'text-indigo-400' : 'text-indigo-600'}`}>
                                                Level {user.level}
                                            </span>
                                            <span className={`font-body text-xs ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                                                {user.xp}/{xpForNextLevel} XP
                                            </span>
                                        </div>
                                        <div className={`w-full h-2 ${nightMode ? 'bg-slate-700' : 'bg-slate-200'}`}>
                                            <motion.div
                                                className="h-full bg-gradient-to-r from-indigo-500 to-purple-500"
                                                initial={{ width: 0 }}
                                                animate={{ width: `${xpProgress}%` }}
                                                transition={{ duration: 0.8, delay: 0.3 }}
                                            />
                                        </div>
                                    </div>
                                )}
                            </div>

                            {/* Stats row */}
                            <div className={`grid grid-cols-2 gap-0 border-b-2 ${nightMode ? 'border-slate-700' : 'border-slate-100'}`}>
                                <div className={`p-3 text-center border-r-2 ${nightMode ? 'border-slate-700' : 'border-slate-100'}`}>
                                    <p className={`font-display text-lg ${nightMode ? 'text-yellow-400' : 'text-yellow-600'}`}>
                                        {user.wins}
                                    </p>
                                    <p className={`font-display text-[7px] uppercase ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                                        Wins
                                    </p>
                                </div>
                                <div className="p-3 text-center">
                                    <p className={`font-display text-lg ${nightMode ? 'text-slate-300' : 'text-slate-700'}`}>
                                        {user.matches}
                                    </p>
                                    <p className={`font-display text-[7px] uppercase ${nightMode ? 'text-slate-500' : 'text-slate-400'}`}>
                                        Matches
                                    </p>
                                </div>
                            </div>

                            {/* Edit Profile + Logout buttons */}
                            <div className="p-3 space-y-2">
                                {onEditProfile && (
                                    <PixelButton variant="secondary" size="sm" className="w-full text-[10px]" onClick={() => {
                                        setShowMenu(false);
                                        onEditProfile();
                                    }}>
                                        ‚úèÔ∏è Edit Profile
                                    </PixelButton>
                                )}
                                <PixelButton variant="danger" size="sm" className="w-full text-[10px]" onClick={() => {
                                    setShowMenu(false);
                                    onLogout();
                                }}>
                                    Log Out
                                </PixelButton>
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </motion.div>
        </div>
    );
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Utility: Get stored session if any
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

export function getStoredSession(): UserProfile | null {
    try {
        const raw = localStorage.getItem(SESSION_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
    } catch {
        return null;
    }
}

export function clearSession() {
    localStorage.removeItem(SESSION_KEY);
}





